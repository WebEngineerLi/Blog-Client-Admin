(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~main~._node_modules_react-hot-loader_dist_react-hot-loader.development.js~35380b4a"],{

/***/ "./node_modules/react-hot-loader/dist/react-hot-loader.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-hot-loader/dist/react-hot-loader.development.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar React__default = _interopDefault(React);\n\nvar shallowEqual = _interopDefault(__webpack_require__(/*! shallowequal */ \"./node_modules/shallowequal/index.js\"));\n\nvar ReactDOM = _interopDefault(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\n\nvar levenshtein = _interopDefault(__webpack_require__(/*! fast-levenshtein */ \"./node_modules/fast-levenshtein/levenshtein.js\"));\n\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\n\nvar defaultPolyfill = __webpack_require__(/*! react-lifecycles-compat */ \"./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\");\n\nvar defaultPolyfill__default = _interopDefault(defaultPolyfill);\n\nvar hoistNonReactStatic = _interopDefault(__webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/* eslint-disable no-underscore-dangle */\n\n\nvar isCompositeComponent = function isCompositeComponent(type) {\n  return typeof type === 'function';\n};\n\nvar isReloadableComponent = function isReloadableComponent(type) {\n  return typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object';\n};\n\nvar getComponentDisplayName = function getComponentDisplayName(type) {\n  var displayName = type.displayName || type.name;\n  return displayName && displayName !== 'ReactComponent' ? displayName : 'Component';\n};\n\nvar reactLifeCycleMountMethods = ['componentWillMount', 'componentDidMount'];\n\nfunction isReactClass(Component) {\n  return !!(Component.prototype && (React__default.Component.prototype.isPrototypeOf(Component.prototype) || // react 14 support\n  Component.prototype.isReactComponent || Component.prototype.componentWillMount || Component.prototype.componentWillUnmount || Component.prototype.componentDidMount || Component.prototype.componentDidUnmount || Component.prototype.render));\n}\n\nfunction isReactClassInstance(Component) {\n  return Component && isReactClass({\n    prototype: Object.getPrototypeOf(Component)\n  });\n}\n\nvar getInternalInstance = function getInternalInstance(instance) {\n  return instance._reactInternalFiber || // React 16\n  instance._reactInternalInstance || // React 15\n  null;\n};\n\nvar updateInstance = function updateInstance(instance) {\n  var updater = instance.updater,\n      forceUpdate = instance.forceUpdate;\n\n  if (typeof forceUpdate === 'function') {\n    instance.forceUpdate();\n  } else if (updater && typeof updater.enqueueForceUpdate === 'function') {\n    updater.enqueueForceUpdate(instance);\n  }\n};\n\nvar isFragmentNode = function isFragmentNode(_ref) {\n  var type = _ref.type;\n  return React__default.Fragment && type === React__default.Fragment;\n};\n\nvar ContextType = React__default.createContext ? React__default.createContext() : null;\nvar ConsumerType = ContextType && ContextType.Consumer.$$typeof;\nvar ProviderType = ContextType && ContextType.Provider.$$typeof;\nvar MemoType = React__default.memo && React__default.memo(function () {\n  return null;\n}).$$typeof;\nvar LazyType = React__default.lazy && React__default.lazy(function () {\n  return null;\n}).$$typeof;\nvar ForwardType = React__default.forwardRef && React__default.forwardRef(function () {\n  return null;\n}).$$typeof;\nvar CONTEXT_CURRENT_VALUE = '_currentValue';\n\nvar isContextConsumer = function isContextConsumer(_ref2) {\n  var type = _ref2.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ConsumerType && ConsumerType;\n};\n\nvar isContextProvider = function isContextProvider(_ref3) {\n  var type = _ref3.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ProviderType && ProviderType;\n};\n\nvar isMemoType = function isMemoType(_ref4) {\n  var type = _ref4.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === MemoType && MemoType;\n};\n\nvar isLazyType = function isLazyType(_ref5) {\n  var type = _ref5.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === LazyType && LazyType;\n};\n\nvar isForwardType = function isForwardType(_ref6) {\n  var type = _ref6.type;\n  return type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && '$$typeof' in type && type.$$typeof === ForwardType && ForwardType;\n};\n\nvar isContextType = function isContextType(type) {\n  return isContextConsumer(type) || isContextProvider(type);\n};\n\nvar getContextProvider = function getContextProvider(type) {\n  return type && type._context;\n};\n\nvar configuration = {\n  // Log level\n  logLevel: 'error',\n  // Allows using SFC without changes\n  pureSFC: true,\n  // keep render method unpatched, moving sideEffect to componentDidUpdate\n  pureRender: true,\n  // Allows SFC to be used, enables \"intermediate\" components used by Relay, should be disabled for Preact\n  allowSFC: true,\n  // Allow hot reload of effect hooks\n  reloadHooks: true,\n  // Disable \"hot-replacement-render\"\n  disableHotRenderer: false,\n  // Disable \"hot-replacement-render\" when injection into react-dom is made\n  disableHotRendererWhenInjected: false,\n  // Controls `react-🔥-dom patch` notification\n  showReactDomPatchNotification: true,\n  // Hook on babel component register.\n  onComponentRegister: false,\n  // Hook on React renders for a first time component\n  onComponentCreate: false,\n  // flag to completely disable RHL for SFC. Probably don't use it without dom patch made.\n  ignoreSFC: false,\n  // ignoreSFC when injection into react-dom is made\n  ignoreSFCWhenInjected: true,\n  // flag to completely disable RHL for Components\n  ignoreComponents: false,\n  // default value for AppContainer errorOverlay\n  errorReporter: undefined,\n  // Global error overlay\n  ErrorOverlay: undefined\n};\nvar internalConfiguration = {\n  // control proxy creation\n  disableProxyCreation: false\n};\n\nvar setConfiguration = function setConfiguration(config) {\n  // not using Object.assing for IE11 compliance\n  for (var i in config) {\n    if (config.hasOwnProperty(i)) {\n      configuration[i] = config[i];\n    }\n  }\n};\n/* eslint-disable no-console */\n\n\nvar logger = {\n  debug: function debug() {\n    if (['debug'].indexOf(configuration.logLevel) !== -1) {\n      var _console;\n\n      (_console = console).debug.apply(_console, arguments);\n    }\n  },\n  log: function log() {\n    if (['debug', 'log'].indexOf(configuration.logLevel) !== -1) {\n      var _console2;\n\n      (_console2 = console).log.apply(_console2, arguments);\n    }\n  },\n  warn: function warn() {\n    if (['debug', 'log', 'warn'].indexOf(configuration.logLevel) !== -1) {\n      var _console3;\n\n      (_console3 = console).warn.apply(_console3, arguments);\n    }\n  },\n  error: function error() {\n    if (['debug', 'log', 'warn', 'error'].indexOf(configuration.logLevel) !== -1) {\n      var _console4;\n\n      (_console4 = console).error.apply(_console4, arguments);\n    }\n  }\n};\n/* eslint-disable no-eval, func-names */\n\nfunction safeReactConstructor(Component, lastInstance) {\n  try {\n    if (lastInstance) {\n      return new Component(lastInstance.props, lastInstance.context);\n    }\n\n    return new Component({}, {});\n  } catch (e) {// some components, like Redux connect could not be created without proper context\n  }\n\n  return null;\n}\n\nfunction isNativeFunction(fn) {\n  return typeof fn === 'function' ? fn.toString().indexOf('[native code]') > 0 : false;\n}\n\nvar identity = function identity(a) {\n  return a;\n};\n\nvar indirectEval = eval;\n\nvar doesSupportClasses = function () {\n  try {\n    indirectEval('class Test {}');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}();\n\nvar ES6ProxyComponentFactory = function ES6ProxyComponentFactory(InitialParent, postConstructionAction) {\n  return indirectEval('\\n(function(InitialParent, postConstructionAction) {\\n  return class ' + (InitialParent.name || 'HotComponent') + ' extends InitialParent {\\n    constructor(props, context) {\\n      super(props, context)\\n      postConstructionAction.call(this)\\n    }\\n  }\\n})\\n')(InitialParent, postConstructionAction);\n};\n\nvar ES5ProxyComponentFactory = function ES5ProxyComponentFactory(InitialParent, postConstructionAction) {\n  function ProxyComponent(props, context) {\n    InitialParent.call(this, props, context);\n    postConstructionAction.call(this);\n  }\n\n  ProxyComponent.prototype = Object.create(InitialParent.prototype);\n  Object.setPrototypeOf(ProxyComponent, InitialParent);\n  return ProxyComponent;\n};\n\nvar proxyClassCreator = doesSupportClasses ? ES6ProxyComponentFactory : ES5ProxyComponentFactory;\n\nfunction getOwnKeys(target) {\n  return [].concat(Object.getOwnPropertyNames(target), Object.getOwnPropertySymbols(target));\n}\n\nfunction shallowStringsEqual(a, b) {\n  for (var key in a) {\n    if (String(a[key]) !== String(b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction deepPrototypeUpdate(dest, source) {\n  var deepDest = Object.getPrototypeOf(dest);\n  var deepSrc = Object.getPrototypeOf(source);\n\n  if (deepDest && deepSrc && deepSrc !== deepDest) {\n    deepPrototypeUpdate(deepDest, deepSrc);\n  }\n\n  if (source.prototype && source.prototype !== dest.prototype) {\n    dest.prototype = source.prototype;\n  }\n}\n\nfunction safeDefineProperty(target, key, props) {\n  try {\n    Object.defineProperty(target, key, props);\n  } catch (e) {\n    logger.warn('Error while wrapping', key, ' -> ', e);\n  }\n}\n\nvar PREFIX = '__reactstandin__';\nvar PROXY_KEY = PREFIX + 'key';\nvar GENERATION = PREFIX + 'proxyGeneration';\nvar REGENERATE_METHOD = PREFIX + 'regenerateByEval';\nvar UNWRAP_PROXY = PREFIX + 'getCurrent';\nvar CACHED_RESULT = PREFIX + 'cachedResult';\nvar PROXY_IS_MOUNTED = PREFIX + 'isMounted';\nvar RENDERED_GENERATION = 'REACT_HOT_LOADER_RENDERED_GENERATION';\nvar RESERVED_STATICS = ['length', 'displayName', 'name', 'arguments', 'caller', 'prototype', 'toString', 'valueOf', 'isStatelessFunctionalProxy', PROXY_KEY, UNWRAP_PROXY];\n\nfunction transferStaticProps(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent) {\n  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    }\n\n    var prevDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n    var savedDescriptor = savedDescriptors[key];\n\n    if (!shallowEqual(prevDescriptor, savedDescriptor)) {\n      safeDefineProperty(NextComponent, key, prevDescriptor);\n    }\n  }); // Copy newly defined static methods and properties\n\n  Object.getOwnPropertyNames(NextComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    }\n\n    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(ProxyComponent, key);\n    var savedDescriptor = savedDescriptors[key]; // Skip redefined descriptors\n\n    if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n      safeDefineProperty(NextComponent, key, prevDescriptor);\n      return;\n    }\n\n    if (prevDescriptor && !savedDescriptor) {\n      safeDefineProperty(ProxyComponent, key, prevDescriptor);\n      return;\n    }\n\n    var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {\n      configurable: true\n    });\n\n    savedDescriptors[key] = nextDescriptor;\n    safeDefineProperty(ProxyComponent, key, nextDescriptor);\n  }); // Remove static methods and properties that are no longer defined\n\n  Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {\n    if (RESERVED_STATICS.indexOf(key) !== -1) {\n      return;\n    } // Skip statics that exist on the next class\n\n\n    if (NextComponent.hasOwnProperty(key)) {\n      return;\n    } // Skip non-configurable statics\n\n\n    var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);\n\n    if (proxyDescriptor && !proxyDescriptor.configurable) {\n      return;\n    }\n\n    var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);\n    var savedDescriptor = savedDescriptors[key]; // Skip redefined descriptors\n\n    if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {\n      return;\n    }\n\n    safeDefineProperty(ProxyComponent, key, {\n      value: undefined\n    });\n  });\n  return savedDescriptors;\n}\n\nfunction mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers) {\n  var injectedCode = {};\n\n  try {\n    var nextInstance = safeReactConstructor(NextComponent, lastInstance);\n\n    try {\n      // Bypass babel class inheritance checking\n      deepPrototypeUpdate(InitialComponent, NextComponent);\n    } catch (e) {// It was ES6 class\n    }\n\n    var proxyInstance = safeReactConstructor(ProxyComponent, lastInstance);\n\n    if (!nextInstance || !proxyInstance) {\n      return injectedCode;\n    }\n\n    var mergedAttrs = _extends({}, proxyInstance, nextInstance);\n\n    var hasRegenerate = proxyInstance[REGENERATE_METHOD];\n    var ownKeys = getOwnKeys(Object.getPrototypeOf(ProxyComponent.prototype));\n    Object.keys(mergedAttrs).forEach(function (key) {\n      if (key.indexOf(PREFIX) === 0) return;\n      var nextAttr = nextInstance[key];\n      var prevAttr = proxyInstance[key];\n\n      if (nextAttr) {\n        if (isNativeFunction(nextAttr) || isNativeFunction(prevAttr)) {\n          // this is bound method\n          var isSameArity = nextAttr.length === prevAttr.length;\n          var existsInPrototype = ownKeys.indexOf(key) >= 0 || ProxyComponent.prototype[key];\n\n          if ((isSameArity || !prevAttr) && existsInPrototype) {\n            if (hasRegenerate) {\n              injectedCode[key] = 'Object.getPrototypeOf(this)[\\'' + key + '\\'].bind(this)';\n            } else {\n              logger.warn('React Hot Loader:,', 'Non-controlled class', ProxyComponent.name, 'contains a new native or bound function ', key, nextAttr, '. Unable to reproduce');\n            }\n          } else {\n            logger.warn('React Hot Loader:', 'Updated class ', ProxyComponent.name, 'contains native or bound function ', key, nextAttr, '. Unable to reproduce, use arrow functions instead.', '(arity: ' + nextAttr.length + '/' + prevAttr.length + ', proto: ' + (existsInPrototype ? 'yes' : 'no'));\n          }\n\n          return;\n        }\n\n        var nextString = String(nextAttr);\n        var injectedBefore = injectedMembers[key];\n        var isArrow = nextString.indexOf('=>') >= 0;\n        var isFunction = nextString.indexOf('function') >= 0 || isArrow;\n        var referToThis = nextString.indexOf('this') >= 0;\n\n        if (nextString !== String(prevAttr) || injectedBefore && nextString !== String(injectedBefore) || isArrow && referToThis) {\n          if (!hasRegenerate) {\n            if (!isFunction) {\n              // just copy prop over\n              injectedCode[key] = nextAttr;\n            } else {\n              logger.warn('React Hot Loader:', ' Updated class ', ProxyComponent.name, 'had different code for', key, nextAttr, '. Unable to reproduce. Regeneration support needed.');\n            }\n          } else {\n            injectedCode[key] = nextAttr;\n          }\n        }\n      }\n    });\n  } catch (e) {\n    logger.warn('React Hot Loader:', e);\n  }\n\n  return injectedCode;\n}\n\nfunction checkLifeCycleMethods(ProxyComponent, NextComponent) {\n  try {\n    var p1 = Object.getPrototypeOf(ProxyComponent.prototype);\n    var p2 = NextComponent.prototype;\n    reactLifeCycleMountMethods.forEach(function (key) {\n      var d1 = Object.getOwnPropertyDescriptor(p1, key) || {\n        value: p1[key]\n      };\n      var d2 = Object.getOwnPropertyDescriptor(p2, key) || {\n        value: p2[key]\n      };\n\n      if (!shallowStringsEqual(d1, d2)) {\n        logger.warn('React Hot Loader:', 'You did update', ProxyComponent.name, 's lifecycle method', key, '. Unable to repeat');\n      }\n    });\n  } catch (e) {// Ignore errors\n  }\n}\n\nfunction inject(target, currentGeneration, injectedMembers) {\n  if (target[GENERATION] !== currentGeneration) {\n    var hasRegenerate = !!target[REGENERATE_METHOD];\n    Object.keys(injectedMembers).forEach(function (key) {\n      try {\n        if (hasRegenerate) {\n          var usedThis = String(injectedMembers[key]).match(/_this([\\d]+)/gi) || [];\n          target[REGENERATE_METHOD](key, '(function REACT_HOT_LOADER_SANDBOX () {\\n          var _this  = this; // common babel transpile\\n          ' + usedThis.map(function (name) {\n            return 'var ' + name + ' = this;';\n          }) + '\\n\\n          return ' + injectedMembers[key] + ';\\n          }).call(this)');\n        } else {\n          target[key] = injectedMembers[key];\n        }\n      } catch (e) {\n        logger.warn('React Hot Loader: Failed to regenerate method ', key, ' of class ', target);\n        logger.warn('got error', e);\n      }\n    });\n    target[GENERATION] = currentGeneration;\n  }\n}\n\nvar has = Object.prototype.hasOwnProperty;\nvar proxies = new WeakMap();\n\nvar resetClassProxies = function resetClassProxies() {\n  proxies = new WeakMap();\n};\n\nvar blackListedClassMembers = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentDidCatch', 'componentWillReceiveProps', 'componentWillUnmount', 'hotComponentRender', 'getInitialState', 'getDefaultProps'];\nvar defaultRenderOptions = {\n  componentWillRender: identity,\n  componentDidUpdate: function componentDidUpdate(result) {\n    return result;\n  },\n  componentDidRender: function componentDidRender(result) {\n    return result;\n  }\n};\n\nvar filteredPrototypeMethods = function filteredPrototypeMethods(Proto) {\n  return Object.getOwnPropertyNames(Proto).filter(function (prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(Proto, prop);\n    return descriptor && prop.indexOf(PREFIX) !== 0 && blackListedClassMembers.indexOf(prop) < 0 && typeof descriptor.value === 'function';\n  });\n};\n\nvar defineClassMember = function defineClassMember(Class, methodName, methodBody) {\n  return safeDefineProperty(Class.prototype, methodName, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    value: methodBody\n  });\n};\n\nvar defineClassMembers = function defineClassMembers(Class, methods) {\n  return Object.keys(methods).forEach(function (methodName) {\n    return defineClassMember(Class, methodName, methods[methodName]);\n  });\n};\n\nvar setSFPFlag = function setSFPFlag(component, flag) {\n  return safeDefineProperty(component, 'isStatelessFunctionalProxy', {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: flag\n  });\n};\n\nvar copyMethodDescriptors = function copyMethodDescriptors(target, source) {\n  if (source) {\n    // it is possible to use `function-double` to construct an ideal clone, but does not make a sence\n    var keys = Object.getOwnPropertyNames(source);\n    keys.forEach(function (key) {\n      return safeDefineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n    safeDefineProperty(target, 'toString', {\n      configurable: true,\n      writable: false,\n      enumerable: false,\n      value: function toString() {\n        return String(source);\n      }\n    });\n  }\n\n  return target;\n};\n\nvar knownClassComponents = [];\n\nvar forEachKnownClass = function forEachKnownClass(cb) {\n  return knownClassComponents.forEach(cb);\n};\n\nfunction createClassProxy(InitialComponent, proxyKey) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var renderOptions = _extends({}, defaultRenderOptions, options);\n\n  var proxyConfig = _extends({}, configuration, options.proxy); // Prevent double wrapping.\n  // Given a proxy class, return the existing proxy managing it.\n\n\n  var existingProxy = proxies.get(InitialComponent);\n\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  var CurrentComponent = void 0;\n  var savedDescriptors = {};\n  var injectedMembers = {};\n  var proxyGeneration = 0;\n  var classUpdatePostponed = null;\n  var instancesCount = 0;\n  var isFunctionalComponent = !isReactClass(InitialComponent);\n  var lastInstance = null;\n\n  function postConstructionAction() {\n    this[GENERATION] = 0;\n    lastInstance = this; // is there is an update pending\n\n    if (classUpdatePostponed) {\n      var callUpdate = classUpdatePostponed;\n      classUpdatePostponed = null;\n      callUpdate();\n    } // As long we can't override constructor\n    // every class shall evolve from a base class\n\n\n    inject(this, proxyGeneration, injectedMembers);\n  }\n\n  function proxiedUpdate() {\n    if (this) {\n      inject(this, proxyGeneration, injectedMembers);\n    }\n  }\n\n  function lifeCycleWrapperFactory(wrapperName) {\n    var sideEffect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n    return copyMethodDescriptors(function wrappedMethod() {\n      proxiedUpdate.call(this);\n      sideEffect(this);\n\n      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {\n        rest[_key] = arguments[_key];\n      }\n\n      return !isFunctionalComponent && CurrentComponent.prototype[wrapperName] && CurrentComponent.prototype[wrapperName].apply(this, rest);\n    }, InitialComponent.prototype && InitialComponent.prototype[wrapperName]);\n  }\n\n  function methodWrapperFactory(wrapperName, realMethod) {\n    return copyMethodDescriptors(function wrappedMethod() {\n      for (var _len2 = arguments.length, rest = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        rest[_key2] = arguments[_key2];\n      }\n\n      return realMethod.apply(this, rest);\n    }, realMethod);\n  }\n\n  var fakeBasePrototype = function fakeBasePrototype(Proto) {\n    return filteredPrototypeMethods(Proto).reduce(function (acc, key) {\n      acc[key] = methodWrapperFactory(key, Proto[key]);\n      return acc;\n    }, {});\n  };\n\n  var componentDidMount = lifeCycleWrapperFactory('componentDidMount', function (target) {\n    target[PROXY_IS_MOUNTED] = true;\n    target[RENDERED_GENERATION] = get$1();\n    instancesCount++;\n  });\n  var componentDidUpdate = lifeCycleWrapperFactory('componentDidUpdate', renderOptions.componentDidUpdate);\n  var componentWillUnmount = lifeCycleWrapperFactory('componentWillUnmount', function (target) {\n    target[PROXY_IS_MOUNTED] = false;\n    instancesCount--;\n  });\n\n  function hotComponentRender() {\n    // repeating subrender call to keep RENDERED_GENERATION up to date\n    renderOptions.componentWillRender(this);\n    proxiedUpdate.call(this);\n    var result = void 0; // We need to use hasOwnProperty here, as the cached result is a React node\n    // and can be null or some other falsy value.\n\n    if (has.call(this, CACHED_RESULT)) {\n      result = this[CACHED_RESULT];\n      delete this[CACHED_RESULT];\n    } else if (isFunctionalComponent) {\n      result = CurrentComponent(this.props, this.context);\n    } else {\n      var renderMethod = CurrentComponent.prototype.render || this.render;\n      /* eslint-disable no-use-before-define */\n\n      if (renderMethod === proxiedRender) {\n        throw new Error('React-Hot-Loader: you are trying to render Component without .render method');\n      }\n      /* eslint-enable */\n\n\n      result = renderMethod.apply(this, // eslint-disable-next-line prefer-rest-params\n      arguments);\n    }\n\n    return renderOptions.componentDidRender.call(this, result);\n  }\n\n  function hotComponentUpdate() {\n    renderOptions.componentWillRender(this);\n    proxiedUpdate.call(this);\n  }\n\n  function proxiedRender() {\n    renderOptions.componentWillRender(this);\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return hotComponentRender.call.apply(hotComponentRender, [this].concat(args));\n  }\n\n  var defineProxyMethods = function defineProxyMethods(Proxy) {\n    var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    defineClassMembers(Proxy, _extends({}, fakeBasePrototype(Base), proxyConfig.pureRender ? {} : {\n      render: proxiedRender\n    }, {\n      hotComponentRender: hotComponentRender,\n      hotComponentUpdate: hotComponentUpdate,\n      componentDidMount: componentDidMount,\n      componentDidUpdate: componentDidUpdate,\n      componentWillUnmount: componentWillUnmount\n    }));\n  };\n\n  var _ProxyFacade = void 0;\n\n  var ProxyComponent = null;\n  var proxy = void 0;\n\n  if (!isFunctionalComponent) {\n    // Component\n    ProxyComponent = proxyClassCreator(InitialComponent, postConstructionAction);\n    defineProxyMethods(ProxyComponent, InitialComponent.prototype);\n    knownClassComponents.push(ProxyComponent);\n    _ProxyFacade = ProxyComponent;\n  } else if (!proxyConfig.allowSFC) {\n    proxyConfig.pureRender = false; // SFC Converted to component. Does not support returning precreated instances from render.\n\n    ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n    defineProxyMethods(ProxyComponent);\n    _ProxyFacade = ProxyComponent;\n  } else {\n    // SFC\n    // This function only gets called for the initial mount. The actual\n    // rendered component instance will be the return value.\n    // eslint-disable-next-line func-names\n    _ProxyFacade = function ProxyFacade(props, context) {\n      var result = CurrentComponent(props, context); // This is a Relay-style container constructor. We can't do the prototype-\n      // style wrapping for this as we do elsewhere, so just we just pass it\n      // through as-is.\n\n      if (isReactClassInstance(result)) {\n        ProxyComponent = null; // Relay lazily sets statics like getDerivedStateFromProps on initial\n        // render in lazy construction, so we need to do the same here.\n\n        transferStaticProps(_ProxyFacade, savedDescriptors, null, CurrentComponent);\n        return result;\n      } // simple SFC, could continue to be SFC\n\n\n      if (proxyConfig.pureSFC) {\n        if (!CurrentComponent.contextTypes) {\n          if (!_ProxyFacade.isStatelessFunctionalProxy) {\n            setSFPFlag(_ProxyFacade, true);\n          }\n\n          return renderOptions.componentDidRender(result);\n        }\n      }\n\n      setSFPFlag(_ProxyFacade, false);\n      proxyConfig.pureRender = false; // Otherwise, it's a normal functional component. Build the real proxy\n      // and use it going forward.\n\n      ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);\n      defineProxyMethods(ProxyComponent);\n      var determinateResult = new ProxyComponent(props, context); // Cache the initial render result so we don't call the component function\n      // a second time for the initial render.\n\n      determinateResult[CACHED_RESULT] = result;\n      return determinateResult;\n    };\n  }\n\n  function get$$1() {\n    return _ProxyFacade;\n  }\n\n  function getCurrent() {\n    return CurrentComponent;\n  }\n\n  safeDefineProperty(_ProxyFacade, UNWRAP_PROXY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: getCurrent\n  });\n  safeDefineProperty(_ProxyFacade, PROXY_KEY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: proxyKey\n  });\n  safeDefineProperty(_ProxyFacade, 'toString', {\n    configurable: true,\n    writable: false,\n    enumerable: false,\n    value: function toString() {\n      return String(CurrentComponent);\n    }\n  });\n\n  function update(NextComponent) {\n    if (typeof NextComponent !== 'function') {\n      throw new Error('Expected a constructor.');\n    }\n\n    if (NextComponent === CurrentComponent) {\n      return;\n    } // Prevent proxy cycles\n\n\n    var existingProxy = proxies.get(NextComponent);\n\n    if (existingProxy) {\n      return;\n    }\n\n    isFunctionalComponent = !isReactClass(NextComponent);\n    proxies.set(NextComponent, proxy);\n    proxyGeneration++; // Save the next constructor so we call it\n\n    var PreviousComponent = CurrentComponent;\n    CurrentComponent = NextComponent; // Try to infer displayName\n\n    var displayName = getComponentDisplayName(CurrentComponent);\n    safeDefineProperty(_ProxyFacade, 'displayName', {\n      configurable: true,\n      writable: false,\n      enumerable: true,\n      value: displayName\n    });\n\n    if (ProxyComponent) {\n      safeDefineProperty(ProxyComponent, 'name', {\n        value: displayName\n      });\n    }\n\n    savedDescriptors = transferStaticProps(_ProxyFacade, savedDescriptors, PreviousComponent, NextComponent);\n    if (isFunctionalComponent || !ProxyComponent) ;else {\n      var classHotReplacement = function classHotReplacement() {\n        getElementCloseHook(ProxyComponent);\n        checkLifeCycleMethods(ProxyComponent, NextComponent);\n\n        if (proxyGeneration > 1) {\n          filteredPrototypeMethods(ProxyComponent.prototype).forEach(function (methodName) {\n            if (!has.call(NextComponent.prototype, methodName)) {\n              delete ProxyComponent.prototype[methodName];\n            }\n          });\n        }\n\n        Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);\n        defineProxyMethods(ProxyComponent, NextComponent.prototype);\n\n        if (proxyGeneration > 1) {\n          injectedMembers = mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers);\n        }\n\n        getElementComparisonHook(ProxyComponent);\n      }; // Was constructed once\n\n\n      if (instancesCount > 0) {\n        classHotReplacement();\n      } else {\n        classUpdatePostponed = classHotReplacement;\n      }\n    }\n  }\n\n  update(InitialComponent);\n\n  var dereference = function dereference() {\n    proxies.delete(InitialComponent);\n    proxies.delete(_ProxyFacade);\n    proxies.delete(CurrentComponent);\n  };\n\n  proxy = {\n    get: get$$1,\n    update: update,\n    dereference: dereference,\n    getCurrent: function getCurrent() {\n      return CurrentComponent;\n    }\n  };\n  proxies.set(InitialComponent, proxy);\n  proxies.set(_ProxyFacade, proxy);\n  safeDefineProperty(proxy, UNWRAP_PROXY, {\n    configurable: false,\n    writable: false,\n    enumerable: false,\n    value: getCurrent\n  });\n  return proxy;\n} // this counter tracks `register` invocations.\n// works good, but code splitting is breaking it\n\n\nvar generation = 1; // these counters are aimed to mitigate the \"first render\"\n\nvar hotComparisonCounter = 0;\nvar hotComparisonRuns = 0;\n\nvar nullFunction = function nullFunction() {\n  return {};\n}; // these callbacks would be called on component update\n\n\nvar onHotComparisonOpen = nullFunction;\nvar onHotComparisonElement = nullFunction;\nvar onHotComparisonClose = nullFunction; // inversion of control\n\nvar setComparisonHooks = function setComparisonHooks(open, element, close) {\n  onHotComparisonOpen = open;\n  onHotComparisonElement = element;\n  onHotComparisonClose = close;\n};\n\nvar getElementComparisonHook = function getElementComparisonHook(component) {\n  return onHotComparisonElement(component);\n};\n\nvar getElementCloseHook = function getElementCloseHook(component) {\n  return onHotComparisonClose(component);\n};\n\nvar hotComparisonOpen = function hotComparisonOpen() {\n  return hotComparisonCounter > 0 && hotComparisonRuns > 0;\n};\n\nvar openGeneration = function openGeneration() {\n  return forEachKnownClass(onHotComparisonElement);\n};\n\nvar closeGeneration = function closeGeneration() {\n  return forEachKnownClass(onHotComparisonClose);\n};\n\nvar incrementHot = function incrementHot() {\n  if (!hotComparisonCounter) {\n    openGeneration();\n    onHotComparisonOpen();\n  }\n\n  hotComparisonCounter++;\n};\n\nvar decrementHot = function decrementHot() {\n  hotComparisonCounter--;\n\n  if (!hotComparisonCounter) {\n    closeGeneration();\n    hotComparisonRuns++;\n  }\n}; // TODO: shall it be called from incrementHotGeneration?\n\n\nvar enterHotUpdate = function enterHotUpdate() {\n  Promise.resolve(incrementHot()).then(function () {\n    return setTimeout(decrementHot, 0);\n  });\n}; // TODO: deprecate?\n\n\nvar increment = function increment() {\n  enterHotUpdate();\n  return generation++;\n};\n\nvar get$1 = function get() {\n  return generation;\n}; // These counters tracks HMR generations, and probably should be used instead of the old one\n\n\nvar hotReplacementGeneration = 0;\n\nvar incrementHotGeneration = function incrementHotGeneration() {\n  return hotReplacementGeneration++;\n};\n\nvar getHotGeneration = function getHotGeneration() {\n  return hotReplacementGeneration;\n};\n\nvar merge = __webpack_require__(/*! lodash/merge */ \"./node_modules/lodash/merge.js\");\n\nvar signatures = void 0;\nvar proxiesByID = void 0;\nvar blackListedProxies = void 0;\nvar registeredComponents = void 0;\nvar idsByType = void 0;\nvar elementCount = 0;\nvar renderOptions = {};\nvar componentOptions = void 0;\n\nvar generateTypeId = function generateTypeId() {\n  return 'auto-' + elementCount++;\n};\n\nvar getIdByType = function getIdByType(type) {\n  return idsByType.get(type);\n};\n\nvar isProxyType = function isProxyType(type) {\n  return type[PROXY_KEY];\n};\n\nvar getProxyById = function getProxyById(id) {\n  return proxiesByID[id];\n};\n\nvar getProxyByType = function getProxyByType(type) {\n  return getProxyById(getIdByType(type));\n};\n\nvar registerComponent = function registerComponent(type) {\n  return registeredComponents.set(type, 1);\n};\n\nvar isRegisteredComponent = function isRegisteredComponent(type) {\n  return registeredComponents.has(type);\n};\n\nvar setStandInOptions = function setStandInOptions(options) {\n  renderOptions = options;\n};\n\nvar updateFunctionProxyById = function updateFunctionProxyById(id, type, updater) {\n  // Remember the ID.\n  idsByType.set(type, id);\n  var proxy = proxiesByID[id];\n\n  if (!proxy) {\n    idsByType.set(type, id);\n    proxiesByID[id] = type;\n  }\n\n  updater(proxiesByID[id], type);\n  return proxiesByID[id];\n};\n\nvar updateProxyById = function updateProxyById(id, type) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!id) {\n    return null;\n  } // Remember the ID.\n\n\n  idsByType.set(type, id);\n\n  if (!proxiesByID[id]) {\n    proxiesByID[id] = createClassProxy(type, id, merge({}, renderOptions, {\n      proxy: componentOptions.get(type) || {}\n    }, options));\n  } else {\n    proxiesByID[id].update(type); // proxy could be registered again only in case of HMR\n\n    incrementHotGeneration();\n  }\n\n  return proxiesByID[id];\n};\n\nvar createProxyForType = function createProxyForType(type, options) {\n  return getProxyByType(type) || updateProxyById(generateTypeId(), type, options);\n};\n\nvar isColdType = function isColdType(type) {\n  return blackListedProxies.has(type);\n};\n\nvar isTypeBlacklisted = function isTypeBlacklisted(type) {\n  return isColdType(type) || isCompositeComponent(type) && (configuration.ignoreSFC && !isReactClass(type) || configuration.ignoreComponents && isReactClass(type));\n};\n\nvar blacklistByType = function blacklistByType(type) {\n  return blackListedProxies.set(type, true);\n};\n\nvar setComponentOptions = function setComponentOptions(component, options) {\n  return componentOptions.set(component, options);\n};\n\nvar addSignature = function addSignature(type, signature) {\n  return signatures.set(type, signature);\n};\n\nvar getSignature = function getSignature(type) {\n  return signatures.get(type);\n};\n\nvar resetProxies = function resetProxies() {\n  proxiesByID = {};\n  idsByType = new WeakMap();\n  blackListedProxies = new WeakMap();\n  registeredComponents = new WeakMap();\n  componentOptions = new WeakMap();\n  signatures = new WeakMap();\n  resetClassProxies();\n};\n\nresetProxies();\nvar tune = {\n  allowSFC: false\n};\n\nvar preactAdapter = function preactAdapter(instance, resolveType) {\n  var oldHandler = instance.options.vnode;\n  setConfiguration(tune);\n\n  instance.options.vnode = function (vnode) {\n    vnode.nodeName = resolveType(vnode.nodeName);\n\n    if (oldHandler) {\n      oldHandler(vnode);\n    }\n  };\n};\n/* global document */\n\n\nvar lastError = [];\nvar overlayStyle = {\n  position: 'fixed',\n  left: 0,\n  top: 0,\n  right: 0,\n  backgroundColor: 'rgba(255,200,200,0.9)',\n  color: '#000',\n  fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif',\n  fontSize: '12px',\n  margin: 0,\n  padding: '16px',\n  maxHeight: '50%',\n  overflow: 'auto'\n};\nvar inlineErrorStyle = {\n  backgroundColor: '#FEE'\n};\nvar liCounter = {\n  position: 'absolute',\n  left: '10px'\n};\nvar listStyle = {};\n\nvar EmptyErrorPlaceholder = function EmptyErrorPlaceholder(_ref) {\n  var component = _ref.component;\n  return React__default.createElement('span', {\n    style: inlineErrorStyle,\n    role: 'img',\n    'aria-label': 'Rect-Hot-Loader Error'\n  }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83E\\uDD15 (', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', ')', component && component.retryHotLoaderError && React__default.createElement('button', {\n    onClick: function onClick() {\n      return component.retryHotLoaderError();\n    },\n    title: 'Retry'\n  }, '\\u27F3'));\n};\n\nvar errorHeader = function errorHeader(component, componentStack) {\n  if (component || componentStack) {\n    return React__default.createElement('span', null, '(', component ? getComponentDisplayName(component.constructor || component) : 'Unknown location', component && ', ', componentStack && componentStack.split('\\n').filter(Boolean)[0], ')');\n  }\n\n  return null;\n};\n\nvar mapError = function mapError(_ref2) {\n  var error = _ref2.error,\n      errorInfo = _ref2.errorInfo,\n      component = _ref2.component;\n  return React__default.createElement(React__default.Fragment, null, React__default.createElement('p', {\n    style: {\n      color: 'red'\n    }\n  }, errorHeader(component, errorInfo && errorInfo.componentStack), ' ', error.toString ? error.toString() : error.message || 'undefined error'), errorInfo && errorInfo.componentStack ? React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', {\n    style: {\n      color: 'red',\n      marginTop: '10px'\n    }\n  }, error.stack.split('\\n').slice(1, 2).map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }), React__default.createElement('hr', null), errorInfo.componentStack.split('\\n').filter(Boolean).map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }))) : error.stack && React__default.createElement('div', null, React__default.createElement('div', null, 'Stack trace:'), React__default.createElement('ul', {\n    style: {\n      color: 'red',\n      marginTop: '10px'\n    }\n  }, error.stack.split('\\n').map(function (line, i) {\n    return React__default.createElement('li', {\n      key: String(i)\n    }, line);\n  }))));\n};\n\nvar ErrorOverlay = function (_React$Component) {\n  inherits(ErrorOverlay, _React$Component);\n\n  function ErrorOverlay() {\n    var _temp, _this, _ret;\n\n    classCallCheck(this, ErrorOverlay);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      visible: true\n    }, _this.toggle = function () {\n      return _this.setState({\n        visible: !_this.state.visible\n      });\n    }, _this.retry = function () {\n      return _this.setState(function () {\n        var errors = _this.props.errors;\n        enterHotUpdate();\n        clearExceptions();\n        errors.map(function (_ref3) {\n          var component = _ref3.component;\n          return component;\n        }).filter(Boolean).filter(function (_ref4) {\n          var retryHotLoaderError = _ref4.retryHotLoaderError;\n          return !!retryHotLoaderError;\n        }).forEach(function (component) {\n          return component.retryHotLoaderError();\n        });\n        return {};\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  ErrorOverlay.prototype.render = function render() {\n    var errors = this.props.errors;\n\n    if (!errors.length) {\n      return null;\n    }\n\n    var visible = this.state.visible;\n    return React__default.createElement('div', {\n      style: overlayStyle\n    }, React__default.createElement('h2', {\n      style: {\n        margin: 0\n      }\n    }, '\\u269B\\uFE0F\\uD83D\\uDD25\\uD83D\\uDE2D: hot update was not successful ', React__default.createElement('button', {\n      onClick: this.toggle\n    }, visible ? 'collapse' : 'expand'), React__default.createElement('button', {\n      onClick: this.retry\n    }, 'Retry')), visible && React__default.createElement('ul', {\n      style: listStyle\n    }, errors.map(function (err, i) {\n      return React__default.createElement('li', {\n        key: i\n      }, React__default.createElement('span', {\n        style: liCounter\n      }, '(', i + 1, '/', errors.length, ')'), mapError(err));\n    })));\n  };\n\n  return ErrorOverlay;\n}(React__default.Component);\n\nvar initErrorOverlay = function initErrorOverlay() {\n  if (typeof document === 'undefined' || !document.body) {\n    return;\n  }\n\n  var div = document.querySelector('.react-hot-loader-error-overlay');\n\n  if (!div) {\n    div = document.createElement('div');\n    div.className = 'react-hot-loader-error-overlay';\n    document.body.appendChild(div);\n  }\n\n  if (lastError.length) {\n    var Overlay = configuration.ErrorOverlay || ErrorOverlay;\n    ReactDOM.render(React__default.createElement(Overlay, {\n      errors: lastError\n    }), div);\n  } else {\n    div.parentNode.removeChild(div);\n  }\n};\n\nfunction clearExceptions() {\n  if (lastError.length) {\n    lastError = [];\n    initErrorOverlay();\n  }\n}\n\nfunction logException(error, errorInfo, component) {\n  // do not suppress error\n\n  /* eslint-disable no-console */\n  console.error(error);\n  /* eslint-enable */\n\n  lastError.push({\n    error: error,\n    errorInfo: errorInfo,\n    component: component\n  });\n  initErrorOverlay();\n}\n/* eslint-disable no-underscore-dangle */\n\n\nvar hotRenderWithHooks = ReactDOM.hotRenderWithHooks || function (fiber, render) {\n  return render();\n};\n\nfunction pushStack(stack, node) {\n  stack.type = node.type;\n  stack.elementType = node.elementType || node.type;\n  stack.children = [];\n  stack.instance = typeof node.type === 'function' ? node.stateNode : stack;\n  stack.fiber = node;\n\n  if (!stack.instance) {\n    stack.instance = {\n      SFC_fake: stack.type,\n      props: {},\n      render: function render() {\n        return hotRenderWithHooks(node, function () {\n          return stack.type(stack.instance.props);\n        });\n      }\n    };\n  }\n}\n\nfunction hydrateFiberStack(node, stack) {\n  pushStack(stack, node);\n\n  if (node.child) {\n    var child = node.child;\n\n    do {\n      var childStack = {};\n      hydrateFiberStack(child, childStack);\n      stack.children.push(childStack);\n      child = child.sibling;\n    } while (child);\n  }\n}\n/* eslint-disable no-underscore-dangle */\n\n\nfunction pushState(stack, type, instance) {\n  stack.type = type;\n  stack.elementType = type;\n  stack.children = [];\n  stack.instance = instance || stack;\n\n  if (typeof type === 'function' && type.isStatelessFunctionalProxy) {\n    // In React 15 SFC is wrapped by component. We have to detect our proxies and change the way it works\n    stack.instance = {\n      SFC_fake: type,\n      props: {},\n      render: function render() {\n        return type(stack.instance.props);\n      }\n    };\n  }\n}\n\nfunction hydrateLegacyStack(node, stack) {\n  if (node._currentElement) {\n    pushState(stack, node._currentElement.type, node._instance || stack);\n  }\n\n  if (node._renderedComponent) {\n    var childStack = {};\n    hydrateLegacyStack(node._renderedComponent, childStack);\n    stack.children.push(childStack);\n  } else if (node._renderedChildren) {\n    Object.keys(node._renderedChildren).forEach(function (key) {\n      var childStack = {};\n      hydrateLegacyStack(node._renderedChildren[key], childStack);\n      stack.children.push(childStack);\n    });\n  }\n}\n/* eslint-disable no-underscore-dangle */\n\n\nfunction getReactStack(instance) {\n  var rootNode = getInternalInstance(instance);\n  var stack = {};\n\n  if (rootNode) {\n    // React stack\n    var isFiber = typeof rootNode.tag === 'number';\n\n    if (isFiber) {\n      hydrateFiberStack(rootNode, stack);\n    } else {\n      hydrateLegacyStack(rootNode, stack);\n    }\n  }\n\n  return stack;\n}\n\nvar markUpdate = function markUpdate(_ref) {\n  var fiber = _ref.fiber;\n\n  if (!fiber) {\n    return;\n  }\n\n  fiber.expirationTime = 1;\n\n  if (fiber.alternate) {\n    fiber.alternate.expirationTime = 1;\n    fiber.alternate.type = fiber.type;\n  }\n\n  if (fiber.memoizedProps && _typeof(fiber.memoizedProps) === 'object') {\n    fiber.memoizedProps = _extends({\n      cacheBusterProp: true\n    }, fiber.memoizedProps);\n  }\n\n  if (fiber.stateNode) ;\n};\n\nvar cleanupReact = function cleanupReact() {\n  if (ReactDOM.hotCleanup) {\n    ReactDOM.hotCleanup();\n  }\n};\n\nvar deepMarkUpdate = function deepMarkUpdate(stack) {\n  markUpdate(stack);\n\n  if (stack.children) {\n    stack.children.forEach(deepMarkUpdate);\n  }\n}; // some `empty` names, React can autoset display name to...\n\n\nvar UNDEFINED_NAMES = {\n  Unknown: true,\n  Component: true\n};\n\nvar areNamesEqual = function areNamesEqual(a, b) {\n  return a === b || UNDEFINED_NAMES[a] && UNDEFINED_NAMES[b];\n};\n\nvar isFunctional = function isFunctional(fn) {\n  return typeof fn === 'function';\n};\n\nvar getTypeOf = function getTypeOf(type) {\n  if (isReactClass(type)) return 'ReactComponent';\n  if (isFunctional(type)) return 'StatelessFunctional';\n  return 'Fragment'; // ?\n};\n\nvar haveTextSimilarity = function haveTextSimilarity(a, b) {\n  return (// equal or slight changed\n    a === b || levenshtein.get(a, b) < a.length * 0.2\n  );\n};\n\nvar getBaseProto = function getBaseProto(source) {\n  return source.prototype.hotComponentRender ? Object.getPrototypeOf(source.prototype) : source.prototype;\n};\n\nvar equalClasses = function equalClasses(a, b) {\n  var prototypeA = getBaseProto(a);\n  var prototypeB = getBaseProto(b);\n  var hits = 0;\n  var misses = 0;\n  var comparisons = 0;\n  Object.getOwnPropertyNames(prototypeA).forEach(function (key) {\n    var descriptorA = Object.getOwnPropertyDescriptor(prototypeA, key);\n    var valueA = descriptorA && (descriptorA.value || descriptorA.get || descriptorA.set);\n    var descriptorB = Object.getOwnPropertyDescriptor(prototypeB, key);\n    var valueB = descriptorB && (descriptorB.value || descriptorB.get || descriptorB.set);\n\n    if (typeof valueA === 'function' && key !== 'constructor') {\n      comparisons++;\n\n      if (haveTextSimilarity(String(valueA), String(valueB))) {\n        hits++;\n      } else {\n        misses++;\n\n        if (key === 'render') {\n          misses++;\n        }\n      }\n    }\n  }); // allow to add or remove one function\n\n  return hits > 0 && misses <= 1 || comparisons === 0;\n};\n\nvar areSwappable = function areSwappable(a, b) {\n  // both are registered components and have the same name\n  if (getIdByType(b) && getIdByType(a) === getIdByType(b)) {\n    return true;\n  }\n\n  if (getTypeOf(a) !== getTypeOf(b)) {\n    return false;\n  }\n\n  if (isReactClass(a)) {\n    return areNamesEqual(getComponentDisplayName(a), getComponentDisplayName(b)) && equalClasses(a, b);\n  }\n\n  if (isFunctional(a)) {\n    var nameA = getComponentDisplayName(a);\n\n    if (!areNamesEqual(nameA, getComponentDisplayName(b))) {\n      return false;\n    }\n\n    return nameA !== 'Component' || haveTextSimilarity(String(a), String(b));\n  }\n\n  return false;\n};\n\nvar shouldNotPatchComponent = function shouldNotPatchComponent(type) {\n  return isTypeBlacklisted(type);\n};\n\nfunction resolveType(type) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (isLazyType({\n    type: type\n  }) || isMemoType({\n    type: type\n  }) || isForwardType({\n    type: type\n  })) {\n    return getProxyByType(type) || type;\n  }\n\n  if (!isCompositeComponent(type) || isProxyType(type)) {\n    return type;\n  }\n\n  var existingProxy = getProxyByType(type);\n\n  if (shouldNotPatchComponent(type)) {\n    return existingProxy ? existingProxy.getCurrent() : type;\n  }\n\n  if (!existingProxy && configuration.onComponentCreate) {\n    configuration.onComponentCreate(type, getComponentDisplayName(type));\n    if (shouldNotPatchComponent(type)) return type;\n  }\n\n  var proxy = internalConfiguration.disableProxyCreation ? existingProxy : createProxyForType(type, options);\n  return proxy ? proxy.get() : type;\n}\n\nvar renderStack = [];\n\nvar stackReport = function stackReport() {\n  var rev = renderStack.slice().reverse();\n  logger.warn('in', rev[0].name, rev);\n};\n\nvar emptyMap = new Map();\n\nvar stackContext = function stackContext() {\n  return (renderStack[renderStack.length - 1] || {}).context || emptyMap;\n};\n\nvar shouldUseRenderMethod = function shouldUseRenderMethod(fn) {\n  return fn && (isReactClassInstance(fn) || fn.SFC_fake);\n};\n\nvar getElementType = function getElementType(child) {\n  return child.type[UNWRAP_PROXY] ? child.type[UNWRAP_PROXY]() : child.type;\n};\n\nvar filterNullArray = function filterNullArray(a) {\n  if (!a) return [];\n  return a.filter(function (x) {\n    return !!x;\n  });\n};\n\nvar unflatten = function unflatten(a) {\n  return a.reduce(function (acc, a) {\n    if (Array.isArray(a)) {\n      acc.push.apply(acc, unflatten(a));\n    } else {\n      acc.push(a);\n    }\n\n    return acc;\n  }, []);\n};\n\nvar isArray = function isArray(fn) {\n  return Array.isArray(fn);\n};\n\nvar asArray = function asArray(a) {\n  return isArray(a) ? a : [a];\n};\n\nvar render = function render(component, stack) {\n  if (!component) {\n    return [];\n  }\n\n  if (component.hotComponentUpdate) {\n    component.hotComponentUpdate();\n  }\n\n  if (shouldUseRenderMethod(component)) {\n    // not calling real render method to prevent call recursion.\n    // stateless components does not have hotComponentRender\n    return component.hotComponentRender ? component.hotComponentRender() : component.render();\n  }\n\n  if (isForwardType(component)) {\n    // render forward type in a sandbox\n    return hotRenderWithHooks(stack.fiber, function () {\n      return component.type.render(component.props, null);\n    });\n  }\n\n  if (isArray(component)) {\n    return component.map(render);\n  }\n\n  if (component.children) {\n    return component.children;\n  }\n\n  return [];\n};\n\nvar NO_CHILDREN = {\n  children: []\n};\n\nvar mapChildren = function mapChildren(children, instances) {\n  return {\n    children: children.filter(function (c) {\n      return c;\n    }).map(function (child, index) {\n      if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || child.isMerged) {\n        return child;\n      }\n\n      var instanceLine = instances[index] || {};\n      var oldChildren = asArray(instanceLine.children || []);\n\n      if (Array.isArray(child)) {\n        return _extends({\n          type: null\n        }, mapChildren(child, oldChildren));\n      }\n\n      var newChildren = asArray(child.props && child.props.children || child.children || []);\n      var nextChildren = child.type !== 'function' && oldChildren.length && mapChildren(newChildren, oldChildren);\n      return _extends({\n        nextProps: child.props,\n        isMerged: true\n      }, instanceLine, nextChildren || {}, {\n        type: child.type\n      });\n    })\n  };\n};\n\nvar mergeInject = function mergeInject(a, b, instance) {\n  if (a && !Array.isArray(a)) {\n    return mergeInject([a], b);\n  }\n\n  if (b && !Array.isArray(b)) {\n    return mergeInject(a, [b]);\n  }\n\n  if (!a || !b) {\n    return NO_CHILDREN;\n  }\n\n  if (a.length === b.length) {\n    return mapChildren(a, b);\n  } // in some cases (no confidence here) B could contain A except null children\n  // in some cases - could not.\n  // this depends on React version and the way you build component.\n\n\n  var nonNullA = filterNullArray(a);\n\n  if (nonNullA.length === b.length) {\n    return mapChildren(nonNullA, b);\n  }\n\n  var flatA = unflatten(nonNullA);\n  var flatB = unflatten(b);\n\n  if (flatA.length === flatB.length) {\n    return mapChildren(flatA, flatB);\n  }\n\n  if (flatB.length === 0 && flatA.length === 1 && _typeof(flatA[0]) !== 'object') ;else if (!reactHotLoader.IS_REACT_MERGE_ENABLED) {\n    logger.warn('React-hot-loader: unable to merge ', a, 'and children of ', instance);\n    stackReport();\n  }\n  return NO_CHILDREN;\n};\n\nvar transformFlowNode = function transformFlowNode(flow) {\n  return flow.reduce(function (acc, node) {\n    if (node && isFragmentNode(node)) {\n      if (node.props && node.props.children) {\n        return [].concat(acc, filterNullArray(asArray(node.props.children)));\n      }\n\n      if (node.children) {\n        return [].concat(acc, filterNullArray(asArray(node.children)));\n      }\n    }\n\n    return [].concat(acc, [node]);\n  }, []);\n};\n\nvar scheduledUpdates = [];\nvar scheduledUpdate = 0;\n\nvar flushScheduledUpdates = function flushScheduledUpdates() {\n  var instances = scheduledUpdates;\n  scheduledUpdates = [];\n  scheduledUpdate = 0;\n  instances.forEach(function (instance) {\n    return instance[PROXY_IS_MOUNTED] && updateInstance(instance);\n  });\n};\n\nvar unscheduleUpdate = function unscheduleUpdate(instance) {\n  scheduledUpdates = scheduledUpdates.filter(function (inst) {\n    return inst !== instance;\n  });\n};\n\nvar scheduleInstanceUpdate = function scheduleInstanceUpdate(instance) {\n  scheduledUpdates.push(instance);\n\n  if (!scheduledUpdate) {\n    scheduledUpdate = setTimeout(flushScheduledUpdates, 4);\n  }\n};\n\nvar hotReplacementRender = function hotReplacementRender(instance, stack) {\n  if (isReactClassInstance(instance)) {\n    var type = getElementType(stack);\n    renderStack.push({\n      name: getComponentDisplayName(type),\n      type: type,\n      props: stack.instance.props,\n      context: stackContext()\n    });\n  }\n\n  try {\n    var flow = transformFlowNode(filterNullArray(asArray(render(instance, stack))));\n    var children = stack.children;\n    flow.forEach(function (child, index) {\n      var childType = child.type;\n      var stackChild = children[index];\n\n      var next = function next(instance) {\n        // copy over props as long new component may be hidden inside them\n        // child does not have all props, as long some of them can be calculated on componentMount.\n        var realProps = instance.props;\n\n        var nextProps = _extends({}, realProps, child.nextProps || {}, child.props || {});\n\n        if (isReactClassInstance(instance) && instance.componentWillUpdate) {\n          // Force-refresh component (bypass redux renderedComponent)\n          instance.componentWillUpdate(_extends({}, realProps), instance.state);\n        }\n\n        instance.props = nextProps;\n        hotReplacementRender(instance, stackChild);\n        instance.props = realProps;\n      }; // text node\n\n\n      if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object' || !stackChild || !stackChild.instance) {\n        if (stackChild && stackChild.children && stackChild.children.length) {\n          logger.error('React-hot-loader: reconciliation failed', 'could not dive into [', child, '] while some elements are still present in the tree.');\n          stackReport();\n        }\n\n        return;\n      } // comparing rendered type to fiber.ElementType\n\n\n      if ((typeof childType === 'undefined' ? 'undefined' : _typeof(childType)) !== _typeof(stackChild.elementType)) {\n        // Portals could generate undefined !== null\n        if (childType && stackChild.type) {\n          logger.warn('React-hot-loader: got ', childType, 'instead of', stackChild.type);\n          stackReport();\n        }\n\n        return;\n      }\n\n      if (isMemoType(child) || isLazyType(child)) {\n        // force update memo children\n        if (stackChild.children && stackChild.children[0]) {\n          scheduleInstanceUpdate(stackChild.children[0].instance);\n        }\n\n        childType = childType.type || childType;\n      }\n\n      if (isForwardType(child)) {\n        next(stackChild.instance);\n      } else if (isContextConsumer(child)) {\n        try {\n          var contextValue = stackContext().get(getContextProvider(childType));\n          next({\n            children: (child.props ? child.props.children : child.children[0])(contextValue !== undefined ? contextValue : childType[CONTEXT_CURRENT_VALUE])\n          });\n        } catch (e) {// do nothing, yet\n        }\n      } else if (typeof childType !== 'function') {\n        // React\n        var childName = childType ? getComponentDisplayName(childType) : 'empty';\n        var extraContext = stackContext();\n\n        if (isContextProvider(child)) {\n          extraContext = new Map(extraContext);\n          extraContext.set(getContextProvider(childType), _extends({}, child.nextProps || {}, child.props || {}).value);\n          childName = 'ContextProvider';\n        }\n\n        renderStack.push({\n          name: childName,\n          type: childType,\n          props: stack.instance.props,\n          context: extraContext\n        });\n        next( // move types from render to the instances of hydrated tree\n        mergeInject(transformFlowNode(asArray(child.props ? child.props.children : child.children)), stackChild.instance.children, stackChild.instance));\n        renderStack.pop();\n      } else {\n        if (childType === stackChild.type) {\n          next(stackChild.instance);\n        } else {\n          // unwrap proxy\n          var _childType = getElementType(child);\n\n          if (isMemoType(child)) {\n            _childType = _childType.type || _childType;\n          }\n\n          if (!stackChild.type[PROXY_KEY]) {\n            if (!reactHotLoader.IS_REACT_MERGE_ENABLED) {\n              if (isTypeBlacklisted(stackChild.type)) {\n                logger.warn('React-hot-loader: cold element got updated ', stackChild.type);\n              }\n            }\n          }\n\n          if (isRegisteredComponent(_childType) || isRegisteredComponent(stackChild.type)) {\n            // one of elements are registered via babel plugin, and should not be handled by hot swap\n            if (resolveType(_childType) === resolveType(stackChild.type)) {\n              next(stackChild.instance);\n            }\n          } else if (areSwappable(_childType, stackChild.type)) {\n            // they are both registered, or have equal code/displayname/signature\n            // update proxy using internal PROXY_KEY\n            updateProxyById(stackChild.type[PROXY_KEY] || getIdByType(stackChild.type), _childType);\n            next(stackChild.instance);\n          } else {\n            logger.warn('React-hot-loader: a ' + getComponentDisplayName(_childType) + ' was found where a ' + getComponentDisplayName(stackChild) + ' was expected.\\n          ' + _childType);\n            stackReport();\n          }\n        }\n\n        scheduleInstanceUpdate(stackChild.instance);\n      }\n    });\n  } catch (e) {\n    if (e.then) ;else {\n      logger.warn('React-hot-loader: run time error during reconciliation', e);\n    }\n  }\n\n  if (isReactClassInstance(instance)) {\n    renderStack.pop();\n  }\n};\n\nvar hotReplacementRender$1 = function (instance, stack) {\n  if (configuration.disableHotRenderer) {\n    return;\n  }\n\n  try {\n    // disable reconciler to prevent upcoming components from proxying.\n    internalConfiguration.disableProxyCreation = true;\n    renderStack = [];\n    hotReplacementRender(instance, stack);\n  } catch (e) {\n    logger.warn('React-hot-loader: reconcilation failed due to error', e);\n  } finally {\n    internalConfiguration.disableProxyCreation = false;\n  }\n};\n\nvar reconcileHotReplacement = function reconcileHotReplacement(ReactInstance) {\n  var stack = getReactStack(ReactInstance);\n  hotReplacementRender$1(ReactInstance, stack);\n  cleanupReact();\n  deepMarkUpdate(stack);\n};\n\nvar renderReconciler = function renderReconciler(target, force) {\n  // we are not inside parent reconcilation\n  var currentGeneration = get$1();\n  var componentGeneration = target[RENDERED_GENERATION];\n  target[RENDERED_GENERATION] = currentGeneration;\n\n  if (!internalConfiguration.disableProxyCreation) {\n    if ((componentGeneration || force) && componentGeneration !== currentGeneration) {\n      enterHotUpdate();\n      reconcileHotReplacement(target);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction asyncReconciledRender(target) {\n  renderReconciler(target, false);\n}\n\nfunction proxyWrapper(element) {\n  // post wrap on post render\n  if (!internalConfiguration.disableProxyCreation) {\n    unscheduleUpdate(this);\n  }\n\n  if (!element) {\n    return element;\n  }\n\n  if (Array.isArray(element)) {\n    return element.map(proxyWrapper);\n  }\n\n  if (typeof element.type === 'function') {\n    var proxy = getProxyByType(element.type);\n\n    if (proxy) {\n      return _extends({}, element, {\n        type: proxy.get()\n      });\n    }\n  }\n\n  return element;\n}\n\nvar ERROR_STATE = 'react_hot_loader_catched_error';\nvar ERROR_STATE_PROTO = 'react_hot_loader_catched_error-prototype';\nvar OLD_RENDER = 'react_hot_loader_original_render';\n\nfunction componentDidCatch(error, errorInfo) {\n  this[ERROR_STATE] = {\n    location: 'boundary',\n    error: error,\n    errorInfo: errorInfo,\n    generation: get$1()\n  };\n  Object.getPrototypeOf(this)[ERROR_STATE_PROTO] = this[ERROR_STATE];\n\n  if (!configuration.errorReporter) {\n    logException(error, errorInfo, this);\n  }\n\n  this.forceUpdate();\n}\n\nfunction componentRender() {\n  var _ref = this[ERROR_STATE] || {},\n      error = _ref.error,\n      errorInfo = _ref.errorInfo,\n      generation = _ref.generation;\n\n  if (error && generation === get$1()) {\n    return React__default.createElement(configuration.errorReporter || EmptyErrorPlaceholder, {\n      error: error,\n      errorInfo: errorInfo,\n      component: this\n    });\n  }\n\n  if (this.hotComponentUpdate) {\n    this.hotComponentUpdate();\n  }\n\n  try {\n    var _OLD_RENDER$render;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return (_OLD_RENDER$render = this[OLD_RENDER].render).call.apply(_OLD_RENDER$render, [this].concat(args));\n  } catch (renderError) {\n    this[ERROR_STATE] = {\n      location: 'render',\n      error: renderError,\n      generation: get$1()\n    };\n\n    if (!configuration.errorReporter) {\n      logException(renderError, undefined, this);\n    }\n\n    return componentRender.call(this);\n  }\n}\n\nfunction retryHotLoaderError() {\n  delete this[ERROR_STATE];\n  this.forceUpdate();\n}\n\nsetComparisonHooks(function () {\n  return {};\n}, function (component) {\n  if (!hotComparisonOpen()) {\n    return;\n  }\n\n  var prototype = component.prototype;\n\n  if (!prototype[OLD_RENDER]) {\n    var renderDescriptior = Object.getOwnPropertyDescriptor(prototype, 'render');\n    prototype[OLD_RENDER] = {\n      descriptor: renderDescriptior ? renderDescriptior.value : undefined,\n      render: prototype.render\n    };\n    prototype.componentDidCatch = componentDidCatch;\n    prototype.retryHotLoaderError = retryHotLoaderError;\n    prototype.render = componentRender;\n  }\n\n  delete prototype[ERROR_STATE];\n}, function (_ref2) {\n  var prototype = _ref2.prototype;\n\n  if (prototype[OLD_RENDER]) {\n    var _ref3 = prototype[ERROR_STATE_PROTO] || {},\n        generation = _ref3.generation;\n\n    if (generation === get$1()) ;else {\n      delete prototype.componentDidCatch;\n      delete prototype.retryHotLoaderError;\n\n      if (!prototype[OLD_RENDER].descriptor) {\n        delete prototype.render;\n      } else {\n        prototype.render = prototype[OLD_RENDER].descriptor;\n      }\n\n      delete prototype[ERROR_STATE_PROTO];\n      delete prototype[OLD_RENDER];\n    }\n  }\n});\nsetStandInOptions({\n  componentWillRender: asyncReconciledRender,\n  componentDidRender: proxyWrapper,\n  componentDidUpdate: function componentDidUpdate(component) {\n    component[RENDERED_GENERATION] = get$1();\n    flushScheduledUpdates();\n  }\n});\n\nvar AppContainer = function (_React$Component) {\n  inherits(AppContainer, _React$Component);\n\n  AppContainer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.generation !== get$1()) {\n      // Hot reload is happening.\n      return {\n        error: null,\n        generation: get$1()\n      };\n    }\n\n    return null;\n  };\n\n  function AppContainer(props) {\n    classCallCheck(this, AppContainer);\n\n    var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    if (configuration.showReactDomPatchNotification) {\n      configuration.showReactDomPatchNotification = false;\n      console.warn('React-Hot-Loader: react-🔥-dom patch is not detected. React 16.6+ features may not work.');\n    }\n\n    _this.state = {\n      error: null,\n      errorInfo: null,\n      // eslint-disable-next-line react/no-unused-state\n      generation: 0\n    };\n    return _this;\n  }\n\n  AppContainer.prototype.shouldComponentUpdate = function shouldComponentUpdate(prevProps, prevState) {\n    // Don't update the component if the state had an error and still has one.\n    // This allows to break an infinite loop of error -> render -> error -> render\n    // https://github.com/gaearon/react-hot-loader/issues/696\n    if (prevState.error && this.state.error) {\n      return false;\n    }\n\n    return true;\n  };\n\n  AppContainer.prototype.componentDidCatch = function componentDidCatch(error, errorInfo) {\n    logger.error(error);\n\n    if (!hotComparisonOpen()) {\n      // do not log error outside of HMR cycle\n      // trigger update to kick error\n      this.setState({});\n      throw error;\n    }\n\n    var _props$errorReporter = this.props.errorReporter,\n        errorReporter = _props$errorReporter === undefined ? configuration.errorReporter : _props$errorReporter;\n\n    if (!errorReporter) {\n      logException(error, errorInfo, this);\n    }\n\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  };\n\n  AppContainer.prototype.retryHotLoaderError = function retryHotLoaderError$$1() {\n    var _this2 = this;\n\n    this.setState({\n      error: null\n    }, function () {\n      retryHotLoaderError.call(_this2);\n    });\n  };\n\n  AppContainer.prototype.render = function render() {\n    var _state = this.state,\n        error = _state.error,\n        errorInfo = _state.errorInfo;\n    var _props$errorReporter2 = this.props.errorReporter,\n        ErrorReporter = _props$errorReporter2 === undefined ? configuration.errorReporter || EmptyErrorPlaceholder : _props$errorReporter2;\n\n    if (error && this.props.errorBoundary) {\n      return React__default.createElement(ErrorReporter, {\n        error: error,\n        errorInfo: errorInfo,\n        component: this\n      });\n    }\n\n    if (this.hotComponentUpdate) {\n      this.hotComponentUpdate();\n    } else {\n      throw new Error('React-Hot-Loader: AppContainer should be patched');\n    }\n\n    return React__default.Children.only(this.props.children);\n  };\n\n  return AppContainer;\n}(React__default.Component);\n\nAppContainer.reactHotLoadable = false;\nAppContainer.propTypes = {\n  children: function children(props) {\n    if (React__default.Children.count(props.children) !== 1) {\n      return new Error('Invalid prop \"children\" supplied to AppContainer. ' + 'Expected a single React element with your app’s root component, e.g. <App />.');\n    }\n\n    return undefined;\n  },\n  errorReporter: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n  errorBoundary: PropTypes.bool\n};\nAppContainer.defaultProps = {\n  errorBoundary: true\n}; //  trying first react-lifecycles-compat.polyfill, then trying react-lifecycles-compat, which could be .default\n\nvar realPolyfill = defaultPolyfill.polyfill || defaultPolyfill__default;\nrealPolyfill(AppContainer);\nvar lazyConstructor = '_ctor';\n\nvar updateLazy = function updateLazy(target, type) {\n  var ctor = type[lazyConstructor];\n\n  if (target[lazyConstructor] !== type[lazyConstructor]) {\n    // just execute `import` and RHL.register will do the job\n    ctor();\n  }\n\n  if (!target[lazyConstructor].isPatchedByReactHotLoader) {\n    target[lazyConstructor] = function () {\n      return ctor().then(function (m) {\n        var C = resolveType(m.default); // chunks has been updated - new hot loader process is taking a place\n\n        enterHotUpdate();\n\n        if (!React__default.forwardRef) {\n          return {\n            default: function _default(props) {\n              return React__default.createElement(AppContainer, null, React__default.createElement(C, props));\n            }\n          };\n        }\n\n        return {\n          default: React__default.forwardRef(function (props, ref) {\n            return React__default.createElement(AppContainer, null, React__default.createElement(C, _extends({}, props, {\n              ref: ref\n            })));\n          })\n        };\n      });\n    };\n\n    target[lazyConstructor].isPatchedByReactHotLoader = true;\n  }\n};\n\nvar updateMemo = function updateMemo(target, _ref) {\n  var type = _ref.type;\n  target.type = resolveType(type);\n};\n\nvar updateForward = function updateForward(target, _ref2) {\n  var render = _ref2.render;\n  target.render = render;\n};\n\nvar updateContext = function updateContext() {// nil\n};\n\nvar getInnerComponentType = function getInnerComponentType(component) {\n  var unwrapper = component[UNWRAP_PROXY];\n  return unwrapper ? unwrapper() : component;\n};\n\nfunction haveEqualSignatures(prevType, nextType) {\n  var prevSignature = getSignature(prevType);\n  var nextSignature = getSignature(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n\n  if (prevSignature.key !== nextSignature.key) {\n    return false;\n  } // TODO: we might need to calculate previous signature earlier in practice,\n  // such as during the first time a component is resolved. We'll revisit this.\n\n\n  var prevCustomHooks = prevSignature.getCustomHooks();\n  var nextCustomHooks = nextSignature.getCustomHooks();\n\n  if (prevCustomHooks.length !== nextCustomHooks.length) {\n    return false;\n  }\n\n  for (var i = 0; i < nextCustomHooks.length; i++) {\n    if (!haveEqualSignatures(prevCustomHooks[i], nextCustomHooks[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar areSignaturesCompatible = function areSignaturesCompatible(a, b) {\n  // compare signatures of two components\n  // non-equal component have to remount and there is two options to do it\n  // - fail the comparison, remounting all tree below\n  // - fulfill it, but set `_debugNeedsRemount` on a fiber to drop only local state\n  // the second way is not published yet, so going with the first one\n  if (!haveEqualSignatures(a, b)) {\n    logger.warn('⚛️🔥🎣 Hook order change detected: component', a, 'has been remounted');\n    return false;\n  }\n\n  return true;\n};\n\nvar compareRegistered = function compareRegistered(a, b) {\n  if (isRegisteredComponent(a) || isRegisteredComponent(b)) {\n    if (resolveType(a) !== resolveType(b)) {\n      return false;\n    }\n  }\n\n  return areSignaturesCompatible(a, b);\n};\n\nvar compareComponents = function compareComponents(oldType, newType, setNewType, baseType) {\n  var defaultResult = oldType === newType;\n\n  if (oldType && !newType || !oldType && newType) {\n    return false;\n  }\n\n  if (isRegisteredComponent(oldType) || isRegisteredComponent(newType)) {\n    if (!compareRegistered(oldType, newType)) {\n      return false;\n    }\n\n    defaultResult = true;\n  }\n\n  if (isForwardType({\n    type: oldType\n  }) && isForwardType({\n    type: newType\n  })) {\n    if (!compareRegistered(oldType.render, newType.render)) {\n      return false;\n    }\n\n    if (oldType.render === newType.render || areSwappable(oldType.render, newType.render)) {\n      setNewType(newType);\n      return true;\n    }\n\n    return defaultResult;\n  }\n\n  if (isMemoType({\n    type: oldType\n  }) && isMemoType({\n    type: newType\n  })) {\n    if (!compareRegistered(oldType.type, newType.type)) {\n      return false;\n    }\n\n    if (oldType.type === newType.type || areSwappable(oldType.type, newType.type)) {\n      if (baseType) {\n        // memo form different fibers, why?\n        if (baseType.$$typeof === newType.$$typeof) {\n          setNewType(newType);\n        } else {\n          setNewType(newType.type);\n        }\n      } else {\n        logger.warn('Please update hot-loader/react-dom');\n\n        if (isReactClass(newType.type)) {\n          setNewType(newType);\n        } else {\n          setNewType(newType.type);\n        }\n      }\n\n      return true;\n    }\n\n    return defaultResult;\n  }\n\n  if (defaultResult || newType !== oldType && areSignaturesCompatible(newType, oldType) && areSwappable(newType, oldType)) {\n    var unwrapFactory = newType[UNWRAP_PROXY];\n    var oldProxy = unwrapFactory && getProxyByType(unwrapFactory());\n\n    if (oldProxy) {\n      oldProxy.dereference();\n      updateProxyById(oldType[PROXY_KEY] || getIdByType(oldType), getInnerComponentType(newType));\n    } else {\n      setNewType(newType);\n    }\n\n    return true;\n  }\n\n  return defaultResult;\n};\n\nvar knownPairs = new WeakMap();\nvar emptyMap$1 = new WeakMap();\n\nvar hotComponentCompare = function hotComponentCompare(oldType, preNewType, setNewType, baseType) {\n  var hotActive = hotComparisonOpen();\n  var newType = configuration.intergratedResolver ? resolveType(preNewType) : preNewType;\n  var result = oldType === newType;\n\n  if (result || !isReloadableComponent(oldType) || !isReloadableComponent(newType) || isColdType(oldType) || isColdType(oldType) || !oldType || !newType || 0) {\n    return result;\n  } // comparison should be active only if hot update window\n  // or it would merge components it shall not\n\n\n  if (hotActive) {\n    result = compareComponents(oldType, newType, setNewType, baseType);\n\n    var _pair = knownPairs.get(oldType) || new WeakMap();\n\n    _pair.set(newType, result);\n\n    knownPairs.set(oldType, _pair);\n    return result;\n  }\n\n  if (result) {\n    return result;\n  }\n\n  var pair = knownPairs.get(oldType) || emptyMap$1;\n  return pair.get(newType) || false;\n};\n/* eslint-disable no-use-before-define */\n\n\nvar forceSimpleSFC = {\n  proxy: {\n    pureSFC: true\n  }\n};\n\nvar hookWrapper = function hookWrapper(hook) {\n  var wrappedHook = function wrappedHook(cb, deps) {\n    if (configuration.reloadHooks) {\n      return hook(cb, deps && deps.length > 0 ? [].concat(deps, [getHotGeneration()]) : deps);\n    }\n\n    return hook(cb, deps);\n  };\n\n  wrappedHook.isPatchedByReactHotLoader = true;\n  return wrappedHook;\n};\n\nvar noDeps = function noDeps() {\n  return [];\n};\n\nvar reactHotLoader = {\n  IS_REACT_MERGE_ENABLED: false,\n  signature: function signature(type, key) {\n    var getCustomHooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noDeps;\n    addSignature(type, {\n      key: key,\n      getCustomHooks: getCustomHooks\n    });\n    return type;\n  },\n  register: function register(type, uniqueLocalName, fileName) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var id = fileName + '#' + uniqueLocalName;\n\n    if (isCompositeComponent(type) && typeof uniqueLocalName === 'string' && uniqueLocalName && typeof fileName === 'string' && fileName) {\n      var proxy = getProxyById(id);\n\n      if (proxy && proxy.getCurrent() !== type) {\n        if (!reactHotLoader.IS_REACT_MERGE_ENABLED) {\n          if (isTypeBlacklisted(type) || isTypeBlacklisted(proxy.getCurrent())) {\n            logger.error('React-hot-loader: Cold component', uniqueLocalName, 'at', fileName, 'has been updated');\n          }\n        }\n      }\n\n      if (configuration.onComponentRegister) {\n        configuration.onComponentRegister(type, uniqueLocalName, fileName);\n      }\n\n      if (configuration.onComponentCreate) {\n        configuration.onComponentCreate(type, getComponentDisplayName(type));\n      }\n\n      registerComponent(updateProxyById(id, type, options).get(), 2);\n      registerComponent(type);\n      increment();\n    }\n\n    if (isContextType({\n      type: type\n    })) {\n      // possible options - Context, Consumer, Provider.\n      ['Provider', 'Consumer'].forEach(function (prop) {\n        var descriptor = Object.getOwnPropertyDescriptor(type, prop);\n\n        if (descriptor && descriptor.value) {\n          updateFunctionProxyById(id + ':' + prop, descriptor.value, updateContext);\n        }\n      });\n      updateFunctionProxyById(id, type, updateContext);\n      increment();\n    }\n\n    if (isLazyType({\n      type: type\n    })) {\n      updateFunctionProxyById(id, type, updateLazy);\n      increment();\n    }\n\n    if (isForwardType({\n      type: type\n    })) {\n      reactHotLoader.register(type.render, uniqueLocalName + ':render', fileName, forceSimpleSFC);\n      updateFunctionProxyById(id, type, updateForward);\n      increment();\n    }\n\n    if (isMemoType({\n      type: type\n    })) {\n      reactHotLoader.register(type.type, uniqueLocalName + ':memo', fileName, forceSimpleSFC);\n      updateFunctionProxyById(id, type, updateMemo);\n      increment();\n    }\n  },\n  reset: function reset() {\n    resetProxies();\n  },\n  preact: function preact(instance) {\n    preactAdapter(instance, resolveType);\n  },\n  resolveType: function resolveType$$1(type) {\n    return resolveType(type);\n  },\n  patch: function patch(React$$1, ReactDOM$$1) {\n    /* eslint-disable no-console */\n    if (ReactDOM$$1 && ReactDOM$$1.setHotElementComparator) {\n      ReactDOM$$1.setHotElementComparator(hotComponentCompare);\n      configuration.disableHotRenderer = configuration.disableHotRendererWhenInjected;\n      configuration.ignoreSFC = configuration.ignoreSFCWhenInjected;\n      reactHotLoader.IS_REACT_MERGE_ENABLED = true;\n      configuration.showReactDomPatchNotification = false;\n\n      if (ReactDOM$$1.setHotTypeResolver) {\n        configuration.intergratedResolver = true;\n        ReactDOM$$1.setHotTypeResolver(resolveType);\n      }\n    }\n\n    if (!configuration.intergratedResolver) {\n      /* eslint-enable */\n      if (!React$$1.createElement.isPatchedByReactHotLoader) {\n        var originalCreateElement = React$$1.createElement; // Trick React into rendering a proxy so that\n        // its state is preserved when the class changes.\n        // This will update the proxy if it's for a known type.\n\n        React$$1.createElement = function (type) {\n          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          return originalCreateElement.apply(undefined, [resolveType(type)].concat(args));\n        };\n\n        React$$1.createElement.isPatchedByReactHotLoader = true;\n      }\n\n      if (!React$$1.cloneElement.isPatchedByReactHotLoader) {\n        var originalCloneElement = React$$1.cloneElement;\n\n        React$$1.cloneElement = function (element) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          var newType = element.type && resolveType(element.type);\n\n          if (newType && newType !== element.type) {\n            return originalCloneElement.apply(undefined, [_extends({}, element, {\n              type: newType\n            })].concat(args));\n          }\n\n          return originalCloneElement.apply(undefined, [element].concat(args));\n        };\n\n        React$$1.cloneElement.isPatchedByReactHotLoader = true;\n      }\n\n      if (!React$$1.createFactory.isPatchedByReactHotLoader) {\n        // Patch React.createFactory to use patched createElement\n        // because the original implementation uses the internal,\n        // unpatched ReactElement.createElement\n        React$$1.createFactory = function (type) {\n          var factory = React$$1.createElement.bind(null, type);\n          factory.type = type;\n          return factory;\n        };\n\n        React$$1.createFactory.isPatchedByReactHotLoader = true;\n      }\n\n      if (!React$$1.Children.only.isPatchedByReactHotLoader) {\n        var originalChildrenOnly = React$$1.Children.only; // Use the same trick as React.createElement\n\n        React$$1.Children.only = function (children) {\n          return originalChildrenOnly(_extends({}, children, {\n            type: resolveType(children.type)\n          }));\n        };\n\n        React$$1.Children.only.isPatchedByReactHotLoader = true;\n      }\n    }\n\n    if (React$$1.useEffect && !React$$1.useEffect.isPatchedByReactHotLoader) {\n      React$$1.useEffect = hookWrapper(React$$1.useEffect);\n      React$$1.useLayoutEffect = hookWrapper(React$$1.useLayoutEffect);\n      React$$1.useCallback = hookWrapper(React$$1.useCallback);\n      React$$1.useMemo = hookWrapper(React$$1.useMemo);\n    } // reactHotLoader.reset()\n\n  }\n};\nvar openedModules = {};\nvar lastModuleOpened = '';\n\nvar getLastModuleOpened = function getLastModuleOpened() {\n  return lastModuleOpened;\n};\n\nvar hotModules = {};\n\nvar createHotModule = function createHotModule() {\n  return {\n    instances: [],\n    updateTimeout: 0\n  };\n};\n\nvar hotModule = function hotModule(moduleId) {\n  if (!hotModules[moduleId]) {\n    hotModules[moduleId] = createHotModule();\n  }\n\n  return hotModules[moduleId];\n};\n\nvar isOpened = function isOpened(sourceModule) {\n  return sourceModule && !!openedModules[sourceModule.id];\n};\n\nvar enter = function enter(sourceModule) {\n  if (sourceModule && sourceModule.id) {\n    lastModuleOpened = sourceModule.id;\n    openedModules[sourceModule.id] = true;\n  } else {\n    logger.warn('React-hot-loader: no `module` variable found. Did you shadow a system variable?');\n  }\n};\n\nvar leave = function leave(sourceModule) {\n  if (sourceModule && sourceModule.id) {\n    delete openedModules[sourceModule.id];\n  }\n};\n/* eslint-disable camelcase, no-undef */\n\n\nvar requireIndirect =  true ? __webpack_require__ : undefined;\n/* eslint-enable */\n\nvar chargeFailbackTimer = function chargeFailbackTimer(id) {\n  return setTimeout(function () {\n    var error = 'hot update failed for module \"' + id + '\". Last file processed: \"' + getLastModuleOpened() + '\".';\n    logger.error(error);\n    logException({\n      toString: function toString() {\n        return error;\n      }\n    }); // 100 ms more \"code\" tolerant that 0, and would catch error in any case\n  }, 100);\n};\n\nvar clearFailbackTimer = function clearFailbackTimer(timerId) {\n  return clearTimeout(timerId);\n};\n\nvar createHoc = function createHoc(SourceComponent, TargetComponent) {\n  hoistNonReactStatic(TargetComponent, SourceComponent);\n  TargetComponent.displayName = 'HotExported' + getComponentDisplayName(SourceComponent);\n  return TargetComponent;\n};\n\nvar makeHotExport = function makeHotExport(sourceModule, moduleId) {\n  var updateInstances = function updateInstances(possibleError) {\n    if (possibleError && possibleError instanceof Error) {\n      console.error(possibleError);\n      return;\n    }\n\n    var module = hotModule(moduleId);\n    clearTimeout(module.updateTimeout);\n    module.updateTimeout = setTimeout(function () {\n      try {\n        requireIndirect(moduleId);\n      } catch (e) {\n        console.error('React-Hot-Loader: error detected while loading', moduleId);\n        console.error(e);\n      }\n\n      module.instances.forEach(function (inst) {\n        return inst.forceUpdate();\n      });\n    });\n  };\n\n  if (sourceModule.hot) {\n    // Mark as self-accepted for Webpack (callback is an Error Handler)\n    // Update instances for Parcel (callback is an Accept Handler)\n    sourceModule.hot.accept(updateInstances); // Webpack way\n\n    if (sourceModule.hot.addStatusHandler) {\n      if (sourceModule.hot.status() === 'idle') {\n        sourceModule.hot.addStatusHandler(function (status) {\n          if (status === 'apply') {\n            clearExceptions();\n            updateInstances();\n          }\n        });\n      }\n    }\n  } else {\n    logger.warn('React-hot-loader: Hot Module Replacement is not enabled');\n  }\n};\n\nvar hot = function hot(sourceModule) {\n  if (!sourceModule) {\n    // this is fatal\n    throw new Error('React-hot-loader: `hot` was called without any argument provided');\n  }\n\n  var moduleId = sourceModule.id || sourceModule.i || sourceModule.filename;\n\n  if (!moduleId) {\n    console.error('`module` prodived', sourceModule);\n    throw new Error('React-hot-loader: `hot` could not find the `name` of the the `module` you have provided');\n  }\n\n  var module = hotModule(moduleId);\n  makeHotExport(sourceModule, moduleId);\n  clearExceptions();\n  var failbackTimer = chargeFailbackTimer(moduleId);\n  var firstHotRegistered = false; // TODO: Ensure that all exports from this file are react components.\n\n  return function (WrappedComponent, props) {\n    clearFailbackTimer(failbackTimer); // register proxy for wrapped component\n    // only one hot per file would use this registration\n\n    if (!firstHotRegistered) {\n      firstHotRegistered = true;\n      reactHotLoader.register(WrappedComponent, getComponentDisplayName(WrappedComponent), 'RHL' + moduleId);\n    }\n\n    return createHoc(WrappedComponent, function (_Component) {\n      inherits(ExportedComponent, _Component);\n\n      function ExportedComponent() {\n        classCallCheck(this, ExportedComponent);\n        return possibleConstructorReturn(this, _Component.apply(this, arguments));\n      }\n\n      ExportedComponent.prototype.componentDidMount = function componentDidMount() {\n        module.instances.push(this);\n      };\n\n      ExportedComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n        var _this2 = this;\n\n        if (isOpened(sourceModule)) {\n          var componentName = getComponentDisplayName(WrappedComponent);\n          logger.error('React-hot-loader: Detected AppContainer unmount on module \\'' + moduleId + '\\' update.\\n' + ('Did you use \"hot(' + componentName + ')\" and \"ReactDOM.render()\" in the same file?\\n') + ('\"hot(' + componentName + ')\" shall only be used as export.\\n') + 'Please refer to \"Getting Started\" (https://github.com/gaearon/react-hot-loader/).');\n        }\n\n        module.instances = module.instances.filter(function (a) {\n          return a !== _this2;\n        });\n      };\n\n      ExportedComponent.prototype.render = function render() {\n        return React__default.createElement(AppContainer, props, React__default.createElement(WrappedComponent, this.props));\n      };\n\n      return ExportedComponent;\n    }(React.Component));\n  };\n};\n\nvar getProxyOrType = function getProxyOrType(type) {\n  var proxy = getProxyByType(type);\n  return proxy ? proxy.get() : type;\n};\n\nvar areComponentsEqual = function areComponentsEqual(a, b) {\n  return getProxyOrType(a) === getProxyOrType(b);\n};\n\nvar compareOrSwap = function compareOrSwap(oldType, newType) {\n  return hotComponentCompare(oldType, newType);\n};\n\nvar cold = function cold(type) {\n  blacklistByType(type);\n  return type;\n};\n\nvar configureComponent = function configureComponent(component, options) {\n  return setComponentOptions(component, options);\n};\n\nvar setConfig = function setConfig(config) {\n  return setConfiguration(config);\n};\n\nreactHotLoader.patch(React__default, ReactDOM);\nexports.default = reactHotLoader;\nexports.AppContainer = AppContainer;\nexports.hot = hot;\nexports.enterModule = enter;\nexports.leaveModule = leave;\nexports.areComponentsEqual = areComponentsEqual;\nexports.compareOrSwap = compareOrSwap;\nexports.cold = cold;\nexports.configureComponent = configureComponent;\nexports.setConfig = setConfig;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9kaXN0L3JlYWN0LWhvdC1sb2FkZXIuZGV2ZWxvcG1lbnQuanM/YzJjYiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RfX2RlZmF1bHQiLCJzaGFsbG93RXF1YWwiLCJSZWFjdERPTSIsImxldmVuc2h0ZWluIiwiUHJvcFR5cGVzIiwiZGVmYXVsdFBvbHlmaWxsIiwiZGVmYXVsdFBvbHlmaWxsX19kZWZhdWx0IiwiaG9pc3ROb25SZWFjdFN0YXRpYyIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9iaiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJpc0NvbXBvc2l0ZUNvbXBvbmVudCIsInR5cGUiLCJpc1JlbG9hZGFibGVDb21wb25lbnQiLCJnZXRDb21wb25lbnREaXNwbGF5TmFtZSIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlYWN0TGlmZUN5Y2xlTW91bnRNZXRob2RzIiwiaXNSZWFjdENsYXNzIiwiQ29tcG9uZW50IiwiaXNQcm90b3R5cGVPZiIsImlzUmVhY3RDb21wb25lbnQiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVW5tb3VudCIsInJlbmRlciIsImlzUmVhY3RDbGFzc0luc3RhbmNlIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRJbnRlcm5hbEluc3RhbmNlIiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJ1cGRhdGVJbnN0YW5jZSIsInVwZGF0ZXIiLCJmb3JjZVVwZGF0ZSIsImVucXVldWVGb3JjZVVwZGF0ZSIsImlzRnJhZ21lbnROb2RlIiwiX3JlZiIsIkZyYWdtZW50IiwiQ29udGV4dFR5cGUiLCJjcmVhdGVDb250ZXh0IiwiQ29uc3VtZXJUeXBlIiwiQ29uc3VtZXIiLCIkJHR5cGVvZiIsIlByb3ZpZGVyVHlwZSIsIlByb3ZpZGVyIiwiTWVtb1R5cGUiLCJtZW1vIiwiTGF6eVR5cGUiLCJsYXp5IiwiRm9yd2FyZFR5cGUiLCJmb3J3YXJkUmVmIiwiQ09OVEVYVF9DVVJSRU5UX1ZBTFVFIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJfcmVmMiIsImlzQ29udGV4dFByb3ZpZGVyIiwiX3JlZjMiLCJpc01lbW9UeXBlIiwiX3JlZjQiLCJpc0xhenlUeXBlIiwiX3JlZjUiLCJpc0ZvcndhcmRUeXBlIiwiX3JlZjYiLCJpc0NvbnRleHRUeXBlIiwiZ2V0Q29udGV4dFByb3ZpZGVyIiwiX2NvbnRleHQiLCJjb25maWd1cmF0aW9uIiwibG9nTGV2ZWwiLCJwdXJlU0ZDIiwicHVyZVJlbmRlciIsImFsbG93U0ZDIiwicmVsb2FkSG9va3MiLCJkaXNhYmxlSG90UmVuZGVyZXIiLCJkaXNhYmxlSG90UmVuZGVyZXJXaGVuSW5qZWN0ZWQiLCJzaG93UmVhY3REb21QYXRjaE5vdGlmaWNhdGlvbiIsIm9uQ29tcG9uZW50UmVnaXN0ZXIiLCJvbkNvbXBvbmVudENyZWF0ZSIsImlnbm9yZVNGQyIsImlnbm9yZVNGQ1doZW5JbmplY3RlZCIsImlnbm9yZUNvbXBvbmVudHMiLCJlcnJvclJlcG9ydGVyIiwidW5kZWZpbmVkIiwiRXJyb3JPdmVybGF5IiwiaW50ZXJuYWxDb25maWd1cmF0aW9uIiwiZGlzYWJsZVByb3h5Q3JlYXRpb24iLCJzZXRDb25maWd1cmF0aW9uIiwiY29uZmlnIiwibG9nZ2VyIiwiZGVidWciLCJpbmRleE9mIiwiX2NvbnNvbGUiLCJjb25zb2xlIiwiYXBwbHkiLCJsb2ciLCJfY29uc29sZTIiLCJ3YXJuIiwiX2NvbnNvbGUzIiwiZXJyb3IiLCJfY29uc29sZTQiLCJzYWZlUmVhY3RDb25zdHJ1Y3RvciIsImxhc3RJbnN0YW5jZSIsInByb3BzIiwiY29udGV4dCIsImUiLCJpc05hdGl2ZUZ1bmN0aW9uIiwiZm4iLCJ0b1N0cmluZyIsImlkZW50aXR5IiwiYSIsImluZGlyZWN0RXZhbCIsImV2YWwiLCJkb2VzU3VwcG9ydENsYXNzZXMiLCJFUzZQcm94eUNvbXBvbmVudEZhY3RvcnkiLCJJbml0aWFsUGFyZW50IiwicG9zdENvbnN0cnVjdGlvbkFjdGlvbiIsIkVTNVByb3h5Q29tcG9uZW50RmFjdG9yeSIsIlByb3h5Q29tcG9uZW50IiwicHJveHlDbGFzc0NyZWF0b3IiLCJnZXRPd25LZXlzIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNoYWxsb3dTdHJpbmdzRXF1YWwiLCJiIiwiU3RyaW5nIiwiZGVlcFByb3RvdHlwZVVwZGF0ZSIsImRlc3QiLCJkZWVwRGVzdCIsImRlZXBTcmMiLCJzYWZlRGVmaW5lUHJvcGVydHkiLCJQUkVGSVgiLCJQUk9YWV9LRVkiLCJHRU5FUkFUSU9OIiwiUkVHRU5FUkFURV9NRVRIT0QiLCJVTldSQVBfUFJPWFkiLCJDQUNIRURfUkVTVUxUIiwiUFJPWFlfSVNfTU9VTlRFRCIsIlJFTkRFUkVEX0dFTkVSQVRJT04iLCJSRVNFUlZFRF9TVEFUSUNTIiwidHJhbnNmZXJTdGF0aWNQcm9wcyIsInNhdmVkRGVzY3JpcHRvcnMiLCJQcmV2aW91c0NvbXBvbmVudCIsIk5leHRDb21wb25lbnQiLCJmb3JFYWNoIiwicHJldkRlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJzYXZlZERlc2NyaXB0b3IiLCJuZXh0RGVzY3JpcHRvciIsInByb3h5RGVzY3JpcHRvciIsIm1lcmdlQ29tcG9uZW50cyIsIkluaXRpYWxDb21wb25lbnQiLCJpbmplY3RlZE1lbWJlcnMiLCJpbmplY3RlZENvZGUiLCJuZXh0SW5zdGFuY2UiLCJwcm94eUluc3RhbmNlIiwibWVyZ2VkQXR0cnMiLCJoYXNSZWdlbmVyYXRlIiwib3duS2V5cyIsImtleXMiLCJuZXh0QXR0ciIsInByZXZBdHRyIiwiaXNTYW1lQXJpdHkiLCJleGlzdHNJblByb3RvdHlwZSIsIm5leHRTdHJpbmciLCJpbmplY3RlZEJlZm9yZSIsImlzQXJyb3ciLCJpc0Z1bmN0aW9uIiwicmVmZXJUb1RoaXMiLCJjaGVja0xpZmVDeWNsZU1ldGhvZHMiLCJwMSIsInAyIiwiZDEiLCJkMiIsImluamVjdCIsImN1cnJlbnRHZW5lcmF0aW9uIiwidXNlZFRoaXMiLCJtYXRjaCIsIm1hcCIsImhhcyIsInByb3hpZXMiLCJXZWFrTWFwIiwicmVzZXRDbGFzc1Byb3hpZXMiLCJibGFja0xpc3RlZENsYXNzTWVtYmVycyIsImRlZmF1bHRSZW5kZXJPcHRpb25zIiwiY29tcG9uZW50V2lsbFJlbmRlciIsImNvbXBvbmVudERpZFVwZGF0ZSIsInJlc3VsdCIsImNvbXBvbmVudERpZFJlbmRlciIsImZpbHRlcmVkUHJvdG90eXBlTWV0aG9kcyIsIlByb3RvIiwiZmlsdGVyIiwicHJvcCIsImRlc2NyaXB0b3IiLCJkZWZpbmVDbGFzc01lbWJlciIsIkNsYXNzIiwibWV0aG9kTmFtZSIsIm1ldGhvZEJvZHkiLCJkZWZpbmVDbGFzc01lbWJlcnMiLCJtZXRob2RzIiwic2V0U0ZQRmxhZyIsImNvbXBvbmVudCIsImZsYWciLCJjb3B5TWV0aG9kRGVzY3JpcHRvcnMiLCJrbm93bkNsYXNzQ29tcG9uZW50cyIsImZvckVhY2hLbm93bkNsYXNzIiwiY2IiLCJjcmVhdGVDbGFzc1Byb3h5IiwicHJveHlLZXkiLCJvcHRpb25zIiwicmVuZGVyT3B0aW9ucyIsInByb3h5Q29uZmlnIiwicHJveHkiLCJleGlzdGluZ1Byb3h5IiwiZ2V0IiwiQ3VycmVudENvbXBvbmVudCIsInByb3h5R2VuZXJhdGlvbiIsImNsYXNzVXBkYXRlUG9zdHBvbmVkIiwiaW5zdGFuY2VzQ291bnQiLCJpc0Z1bmN0aW9uYWxDb21wb25lbnQiLCJjYWxsVXBkYXRlIiwicHJveGllZFVwZGF0ZSIsImxpZmVDeWNsZVdyYXBwZXJGYWN0b3J5Iiwid3JhcHBlck5hbWUiLCJzaWRlRWZmZWN0Iiwid3JhcHBlZE1ldGhvZCIsIl9sZW4iLCJyZXN0IiwiQXJyYXkiLCJfa2V5IiwibWV0aG9kV3JhcHBlckZhY3RvcnkiLCJyZWFsTWV0aG9kIiwiX2xlbjIiLCJfa2V5MiIsImZha2VCYXNlUHJvdG90eXBlIiwicmVkdWNlIiwiYWNjIiwiZ2V0JDEiLCJob3RDb21wb25lbnRSZW5kZXIiLCJyZW5kZXJNZXRob2QiLCJwcm94aWVkUmVuZGVyIiwiRXJyb3IiLCJob3RDb21wb25lbnRVcGRhdGUiLCJfbGVuMyIsImFyZ3MiLCJfa2V5MyIsImRlZmluZVByb3h5TWV0aG9kcyIsIlByb3h5IiwiQmFzZSIsIl9Qcm94eUZhY2FkZSIsInB1c2giLCJQcm94eUZhY2FkZSIsImNvbnRleHRUeXBlcyIsImlzU3RhdGVsZXNzRnVuY3Rpb25hbFByb3h5IiwiZGV0ZXJtaW5hdGVSZXN1bHQiLCJnZXQkJDEiLCJnZXRDdXJyZW50IiwidXBkYXRlIiwic2V0IiwiY2xhc3NIb3RSZXBsYWNlbWVudCIsImdldEVsZW1lbnRDbG9zZUhvb2siLCJnZXRFbGVtZW50Q29tcGFyaXNvbkhvb2siLCJkZXJlZmVyZW5jZSIsImRlbGV0ZSIsImdlbmVyYXRpb24iLCJob3RDb21wYXJpc29uQ291bnRlciIsImhvdENvbXBhcmlzb25SdW5zIiwibnVsbEZ1bmN0aW9uIiwib25Ib3RDb21wYXJpc29uT3BlbiIsIm9uSG90Q29tcGFyaXNvbkVsZW1lbnQiLCJvbkhvdENvbXBhcmlzb25DbG9zZSIsInNldENvbXBhcmlzb25Ib29rcyIsIm9wZW4iLCJlbGVtZW50IiwiY2xvc2UiLCJob3RDb21wYXJpc29uT3BlbiIsIm9wZW5HZW5lcmF0aW9uIiwiY2xvc2VHZW5lcmF0aW9uIiwiaW5jcmVtZW50SG90IiwiZGVjcmVtZW50SG90IiwiZW50ZXJIb3RVcGRhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJzZXRUaW1lb3V0IiwiaW5jcmVtZW50IiwiaG90UmVwbGFjZW1lbnRHZW5lcmF0aW9uIiwiaW5jcmVtZW50SG90R2VuZXJhdGlvbiIsImdldEhvdEdlbmVyYXRpb24iLCJtZXJnZSIsInNpZ25hdHVyZXMiLCJwcm94aWVzQnlJRCIsImJsYWNrTGlzdGVkUHJveGllcyIsInJlZ2lzdGVyZWRDb21wb25lbnRzIiwiaWRzQnlUeXBlIiwiZWxlbWVudENvdW50IiwiY29tcG9uZW50T3B0aW9ucyIsImdlbmVyYXRlVHlwZUlkIiwiZ2V0SWRCeVR5cGUiLCJpc1Byb3h5VHlwZSIsImdldFByb3h5QnlJZCIsImlkIiwiZ2V0UHJveHlCeVR5cGUiLCJyZWdpc3RlckNvbXBvbmVudCIsImlzUmVnaXN0ZXJlZENvbXBvbmVudCIsInNldFN0YW5kSW5PcHRpb25zIiwidXBkYXRlRnVuY3Rpb25Qcm94eUJ5SWQiLCJ1cGRhdGVQcm94eUJ5SWQiLCJjcmVhdGVQcm94eUZvclR5cGUiLCJpc0NvbGRUeXBlIiwiaXNUeXBlQmxhY2tsaXN0ZWQiLCJibGFja2xpc3RCeVR5cGUiLCJzZXRDb21wb25lbnRPcHRpb25zIiwiYWRkU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiZ2V0U2lnbmF0dXJlIiwicmVzZXRQcm94aWVzIiwidHVuZSIsInByZWFjdEFkYXB0ZXIiLCJyZXNvbHZlVHlwZSIsIm9sZEhhbmRsZXIiLCJ2bm9kZSIsIm5vZGVOYW1lIiwibGFzdEVycm9yIiwib3ZlcmxheVN0eWxlIiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsIm1hcmdpbiIsInBhZGRpbmciLCJtYXhIZWlnaHQiLCJvdmVyZmxvdyIsImlubGluZUVycm9yU3R5bGUiLCJsaUNvdW50ZXIiLCJsaXN0U3R5bGUiLCJFbXB0eUVycm9yUGxhY2Vob2xkZXIiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJyb2xlIiwicmV0cnlIb3RMb2FkZXJFcnJvciIsIm9uQ2xpY2siLCJ0aXRsZSIsImVycm9ySGVhZGVyIiwiY29tcG9uZW50U3RhY2siLCJzcGxpdCIsIkJvb2xlYW4iLCJtYXBFcnJvciIsImVycm9ySW5mbyIsIm1lc3NhZ2UiLCJtYXJnaW5Ub3AiLCJzdGFjayIsInNsaWNlIiwibGluZSIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGVtcCIsIl90aGlzIiwiX3JldCIsInN0YXRlIiwidmlzaWJsZSIsInRvZ2dsZSIsInNldFN0YXRlIiwicmV0cnkiLCJlcnJvcnMiLCJjbGVhckV4Y2VwdGlvbnMiLCJlcnIiLCJpbml0RXJyb3JPdmVybGF5IiwiZG9jdW1lbnQiLCJib2R5IiwiZGl2IiwicXVlcnlTZWxlY3RvciIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiT3ZlcmxheSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImxvZ0V4Y2VwdGlvbiIsImhvdFJlbmRlcldpdGhIb29rcyIsImZpYmVyIiwicHVzaFN0YWNrIiwibm9kZSIsImVsZW1lbnRUeXBlIiwiY2hpbGRyZW4iLCJzdGF0ZU5vZGUiLCJTRkNfZmFrZSIsImh5ZHJhdGVGaWJlclN0YWNrIiwiY2hpbGQiLCJjaGlsZFN0YWNrIiwic2libGluZyIsInB1c2hTdGF0ZSIsImh5ZHJhdGVMZWdhY3lTdGFjayIsIl9jdXJyZW50RWxlbWVudCIsIl9pbnN0YW5jZSIsIl9yZW5kZXJlZENvbXBvbmVudCIsIl9yZW5kZXJlZENoaWxkcmVuIiwiZ2V0UmVhY3RTdGFjayIsInJvb3ROb2RlIiwiaXNGaWJlciIsInRhZyIsIm1hcmtVcGRhdGUiLCJleHBpcmF0aW9uVGltZSIsImFsdGVybmF0ZSIsIm1lbW9pemVkUHJvcHMiLCJjYWNoZUJ1c3RlclByb3AiLCJjbGVhbnVwUmVhY3QiLCJob3RDbGVhbnVwIiwiZGVlcE1hcmtVcGRhdGUiLCJVTkRFRklORURfTkFNRVMiLCJVbmtub3duIiwiYXJlTmFtZXNFcXVhbCIsImlzRnVuY3Rpb25hbCIsImdldFR5cGVPZiIsImhhdmVUZXh0U2ltaWxhcml0eSIsImdldEJhc2VQcm90byIsImVxdWFsQ2xhc3NlcyIsInByb3RvdHlwZUEiLCJwcm90b3R5cGVCIiwiaGl0cyIsIm1pc3NlcyIsImNvbXBhcmlzb25zIiwiZGVzY3JpcHRvckEiLCJ2YWx1ZUEiLCJkZXNjcmlwdG9yQiIsInZhbHVlQiIsImFyZVN3YXBwYWJsZSIsIm5hbWVBIiwic2hvdWxkTm90UGF0Y2hDb21wb25lbnQiLCJyZW5kZXJTdGFjayIsInN0YWNrUmVwb3J0IiwicmV2IiwicmV2ZXJzZSIsImVtcHR5TWFwIiwiTWFwIiwic3RhY2tDb250ZXh0Iiwic2hvdWxkVXNlUmVuZGVyTWV0aG9kIiwiZ2V0RWxlbWVudFR5cGUiLCJmaWx0ZXJOdWxsQXJyYXkiLCJ4IiwidW5mbGF0dGVuIiwiaXNBcnJheSIsImFzQXJyYXkiLCJOT19DSElMRFJFTiIsIm1hcENoaWxkcmVuIiwiaW5zdGFuY2VzIiwiYyIsImluZGV4IiwiaXNNZXJnZWQiLCJpbnN0YW5jZUxpbmUiLCJvbGRDaGlsZHJlbiIsIm5ld0NoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibmV4dFByb3BzIiwibWVyZ2VJbmplY3QiLCJub25OdWxsQSIsImZsYXRBIiwiZmxhdEIiLCJyZWFjdEhvdExvYWRlciIsIklTX1JFQUNUX01FUkdFX0VOQUJMRUQiLCJ0cmFuc2Zvcm1GbG93Tm9kZSIsImZsb3ciLCJzY2hlZHVsZWRVcGRhdGVzIiwic2NoZWR1bGVkVXBkYXRlIiwiZmx1c2hTY2hlZHVsZWRVcGRhdGVzIiwidW5zY2hlZHVsZVVwZGF0ZSIsImluc3QiLCJzY2hlZHVsZUluc3RhbmNlVXBkYXRlIiwiaG90UmVwbGFjZW1lbnRSZW5kZXIiLCJjaGlsZFR5cGUiLCJzdGFja0NoaWxkIiwibmV4dCIsInJlYWxQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb250ZXh0VmFsdWUiLCJjaGlsZE5hbWUiLCJleHRyYUNvbnRleHQiLCJwb3AiLCJfY2hpbGRUeXBlIiwiaG90UmVwbGFjZW1lbnRSZW5kZXIkMSIsInJlY29uY2lsZUhvdFJlcGxhY2VtZW50IiwiUmVhY3RJbnN0YW5jZSIsInJlbmRlclJlY29uY2lsZXIiLCJmb3JjZSIsImNvbXBvbmVudEdlbmVyYXRpb24iLCJhc3luY1JlY29uY2lsZWRSZW5kZXIiLCJwcm94eVdyYXBwZXIiLCJFUlJPUl9TVEFURSIsIkVSUk9SX1NUQVRFX1BST1RPIiwiT0xEX1JFTkRFUiIsImNvbXBvbmVudERpZENhdGNoIiwibG9jYXRpb24iLCJjb21wb25lbnRSZW5kZXIiLCJfT0xEX1JFTkRFUiRyZW5kZXIiLCJyZW5kZXJFcnJvciIsInJlbmRlckRlc2NyaXB0aW9yIiwiQXBwQ29udGFpbmVyIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwicHJldlN0YXRlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwicHJldlByb3BzIiwiX3Byb3BzJGVycm9yUmVwb3J0ZXIiLCJyZXRyeUhvdExvYWRlckVycm9yJCQxIiwiX3RoaXMyIiwiX3N0YXRlIiwiX3Byb3BzJGVycm9yUmVwb3J0ZXIyIiwiRXJyb3JSZXBvcnRlciIsImVycm9yQm91bmRhcnkiLCJDaGlsZHJlbiIsIm9ubHkiLCJyZWFjdEhvdExvYWRhYmxlIiwicHJvcFR5cGVzIiwiY291bnQiLCJvbmVPZlR5cGUiLCJmdW5jIiwiYm9vbCIsImRlZmF1bHRQcm9wcyIsInJlYWxQb2x5ZmlsbCIsInBvbHlmaWxsIiwibGF6eUNvbnN0cnVjdG9yIiwidXBkYXRlTGF6eSIsImN0b3IiLCJpc1BhdGNoZWRCeVJlYWN0SG90TG9hZGVyIiwibSIsIkMiLCJkZWZhdWx0IiwiX2RlZmF1bHQiLCJyZWYiLCJ1cGRhdGVNZW1vIiwidXBkYXRlRm9yd2FyZCIsInVwZGF0ZUNvbnRleHQiLCJnZXRJbm5lckNvbXBvbmVudFR5cGUiLCJ1bndyYXBwZXIiLCJoYXZlRXF1YWxTaWduYXR1cmVzIiwicHJldlR5cGUiLCJuZXh0VHlwZSIsInByZXZTaWduYXR1cmUiLCJuZXh0U2lnbmF0dXJlIiwicHJldkN1c3RvbUhvb2tzIiwiZ2V0Q3VzdG9tSG9va3MiLCJuZXh0Q3VzdG9tSG9va3MiLCJhcmVTaWduYXR1cmVzQ29tcGF0aWJsZSIsImNvbXBhcmVSZWdpc3RlcmVkIiwiY29tcGFyZUNvbXBvbmVudHMiLCJvbGRUeXBlIiwibmV3VHlwZSIsInNldE5ld1R5cGUiLCJiYXNlVHlwZSIsImRlZmF1bHRSZXN1bHQiLCJ1bndyYXBGYWN0b3J5Iiwib2xkUHJveHkiLCJrbm93blBhaXJzIiwiZW1wdHlNYXAkMSIsImhvdENvbXBvbmVudENvbXBhcmUiLCJwcmVOZXdUeXBlIiwiaG90QWN0aXZlIiwiaW50ZXJncmF0ZWRSZXNvbHZlciIsIl9wYWlyIiwicGFpciIsImZvcmNlU2ltcGxlU0ZDIiwiaG9va1dyYXBwZXIiLCJob29rIiwid3JhcHBlZEhvb2siLCJkZXBzIiwibm9EZXBzIiwicmVnaXN0ZXIiLCJ1bmlxdWVMb2NhbE5hbWUiLCJmaWxlTmFtZSIsInJlc2V0IiwicHJlYWN0IiwicmVzb2x2ZVR5cGUkJDEiLCJwYXRjaCIsIlJlYWN0JCQxIiwiUmVhY3RET00kJDEiLCJzZXRIb3RFbGVtZW50Q29tcGFyYXRvciIsInNldEhvdFR5cGVSZXNvbHZlciIsIm9yaWdpbmFsQ3JlYXRlRWxlbWVudCIsImNsb25lRWxlbWVudCIsIm9yaWdpbmFsQ2xvbmVFbGVtZW50IiwiY3JlYXRlRmFjdG9yeSIsImZhY3RvcnkiLCJiaW5kIiwib3JpZ2luYWxDaGlsZHJlbk9ubHkiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJvcGVuZWRNb2R1bGVzIiwibGFzdE1vZHVsZU9wZW5lZCIsImdldExhc3RNb2R1bGVPcGVuZWQiLCJob3RNb2R1bGVzIiwiY3JlYXRlSG90TW9kdWxlIiwidXBkYXRlVGltZW91dCIsImhvdE1vZHVsZSIsIm1vZHVsZUlkIiwiaXNPcGVuZWQiLCJzb3VyY2VNb2R1bGUiLCJlbnRlciIsImxlYXZlIiwicmVxdWlyZUluZGlyZWN0IiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsImNoYXJnZUZhaWxiYWNrVGltZXIiLCJjbGVhckZhaWxiYWNrVGltZXIiLCJ0aW1lcklkIiwiY2xlYXJUaW1lb3V0IiwiY3JlYXRlSG9jIiwiU291cmNlQ29tcG9uZW50IiwiVGFyZ2V0Q29tcG9uZW50IiwibWFrZUhvdEV4cG9ydCIsInVwZGF0ZUluc3RhbmNlcyIsInBvc3NpYmxlRXJyb3IiLCJtb2R1bGUiLCJob3QiLCJhY2NlcHQiLCJhZGRTdGF0dXNIYW5kbGVyIiwic3RhdHVzIiwiZmlsZW5hbWUiLCJmYWlsYmFja1RpbWVyIiwiZmlyc3RIb3RSZWdpc3RlcmVkIiwiV3JhcHBlZENvbXBvbmVudCIsIl9Db21wb25lbnQiLCJFeHBvcnRlZENvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJnZXRQcm94eU9yVHlwZSIsImFyZUNvbXBvbmVudHNFcXVhbCIsImNvbXBhcmVPclN3YXAiLCJjb2xkIiwiY29uZmlndXJlQ29tcG9uZW50Iiwic2V0Q29uZmlnIiwiZW50ZXJNb2R1bGUiLCJsZWF2ZU1vZHVsZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRUMsT0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBRUEsU0FBU0MsZUFBVCxDQUEwQkMsRUFBMUIsRUFBOEI7QUFBRSxTQUFRQSxFQUFFLElBQUssT0FBT0EsRUFBUCxLQUFjLFFBQXJCLElBQWtDLGFBQWFBLEVBQWhELEdBQXNEQSxFQUFFLENBQUMsU0FBRCxDQUF4RCxHQUFzRUEs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LENBQW1CL2hCLE1BQW5CLEVBQTJCO0FBQ3pDLFNBQU9ELGdCQUFnQixDQUFDQyxNQUFELENBQXZCO0FBQ0QsQ0FGRDs7QUFJQXFYLGNBQWMsQ0FBQ2lILEtBQWYsQ0FBcUJ6bEIsY0FBckIsRUFBcUNFLFFBQXJDO0FBRUFSLE9BQU8sQ0FBQ2lqQixPQUFSLEdBQWtCbkUsY0FBbEI7QUFDQTllLE9BQU8sQ0FBQ29oQixZQUFSLEdBQXVCQSxZQUF2QjtBQUNBcGhCLE9BQU8sQ0FBQ3dvQixHQUFSLEdBQWNBLEdBQWQ7QUFDQXhvQixPQUFPLENBQUN5cEIsV0FBUixHQUFzQmhDLEtBQXRCO0FBQ0F6bkIsT0FBTyxDQUFDMHBCLFdBQVIsR0FBc0JoQyxLQUF0QjtBQUNBMW5CLE9BQU8sQ0FBQ29wQixrQkFBUixHQUE2QkEsa0JBQTdCO0FBQ0FwcEIsT0FBTyxDQUFDcXBCLGFBQVIsR0FBd0JBLGFBQXhCO0FBQ0FycEIsT0FBTyxDQUFDc3BCLElBQVIsR0FBZUEsSUFBZjtBQUNBdHBCLE9BQU8sQ0FBQ3VwQixrQkFBUixHQUE2QkEsa0JBQTdCO0FBQ0F2cEIsT0FBTyxDQUFDd3BCLFNBQVIsR0FBb0JBLFNBQXBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvdC1sb2FkZXIvZGlzdC9yZWFjdC1ob3QtbG9hZGVyLmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG52YXIgc2hhbGxvd0VxdWFsID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3NoYWxsb3dlcXVhbCcpKTtcbnZhciBSZWFjdERPTSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdC1kb20nKSk7XG52YXIgbGV2ZW5zaHRlaW4gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZmFzdC1sZXZlbnNodGVpbicpKTtcbnZhciBQcm9wVHlwZXMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncHJvcC10eXBlcycpKTtcbnZhciBkZWZhdWx0UG9seWZpbGwgPSByZXF1aXJlKCdyZWFjdC1saWZlY3ljbGVzLWNvbXBhdCcpO1xudmFyIGRlZmF1bHRQb2x5ZmlsbF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChkZWZhdWx0UG9seWZpbGwpO1xudmFyIGhvaXN0Tm9uUmVhY3RTdGF0aWMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuXG52YXIgaXNDb21wb3NpdGVDb21wb25lbnQgPSBmdW5jdGlvbiBpc0NvbXBvc2l0ZUNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG52YXIgaXNSZWxvYWRhYmxlQ29tcG9uZW50ID0gZnVuY3Rpb24gaXNSZWxvYWRhYmxlQ29tcG9uZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZSkpID09PSAnb2JqZWN0Jztcbn07XG5cbnZhciBnZXRDb21wb25lbnREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGdldENvbXBvbmVudERpc3BsYXlOYW1lKHR5cGUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIHJldHVybiBkaXNwbGF5TmFtZSAmJiBkaXNwbGF5TmFtZSAhPT0gJ1JlYWN0Q29tcG9uZW50JyA/IGRpc3BsYXlOYW1lIDogJ0NvbXBvbmVudCc7XG59O1xuXG52YXIgcmVhY3RMaWZlQ3ljbGVNb3VudE1ldGhvZHMgPSBbJ2NvbXBvbmVudFdpbGxNb3VudCcsICdjb21wb25lbnREaWRNb3VudCddO1xuXG5mdW5jdGlvbiBpc1JlYWN0Q2xhc3MoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIChSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoQ29tcG9uZW50LnByb3RvdHlwZSkgfHxcbiAgLy8gcmVhY3QgMTQgc3VwcG9ydFxuICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCB8fCBDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50IHx8IENvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkVW5tb3VudCB8fCBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcikpO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2xhc3NJbnN0YW5jZShDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudCAmJiBpc1JlYWN0Q2xhc3MoeyBwcm90b3R5cGU6IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb21wb25lbnQpIH0pO1xufVxuXG52YXIgZ2V0SW50ZXJuYWxJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLl9yZWFjdEludGVybmFsRmliZXIgfHwgLy8gUmVhY3QgMTZcbiAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSB8fCAvLyBSZWFjdCAxNVxuICBudWxsO1xufTtcblxudmFyIHVwZGF0ZUluc3RhbmNlID0gZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIHVwZGF0ZXIgPSBpbnN0YW5jZS51cGRhdGVyLFxuICAgICAgZm9yY2VVcGRhdGUgPSBpbnN0YW5jZS5mb3JjZVVwZGF0ZTtcblxuICBpZiAodHlwZW9mIGZvcmNlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgfSBlbHNlIGlmICh1cGRhdGVyICYmIHR5cGVvZiB1cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIGlzRnJhZ21lbnROb2RlID0gZnVuY3Rpb24gaXNGcmFnbWVudE5vZGUoX3JlZikge1xuICB2YXIgdHlwZSA9IF9yZWYudHlwZTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LkZyYWdtZW50ICYmIHR5cGUgPT09IFJlYWN0X19kZWZhdWx0LkZyYWdtZW50O1xufTtcblxudmFyIENvbnRleHRUeXBlID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCA/IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQoKSA6IG51bGw7XG52YXIgQ29uc3VtZXJUeXBlID0gQ29udGV4dFR5cGUgJiYgQ29udGV4dFR5cGUuQ29uc3VtZXIuJCR0eXBlb2Y7XG52YXIgUHJvdmlkZXJUeXBlID0gQ29udGV4dFR5cGUgJiYgQ29udGV4dFR5cGUuUHJvdmlkZXIuJCR0eXBlb2Y7XG52YXIgTWVtb1R5cGUgPSBSZWFjdF9fZGVmYXVsdC5tZW1vICYmIFJlYWN0X19kZWZhdWx0Lm1lbW8oZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn0pLiQkdHlwZW9mO1xudmFyIExhenlUeXBlID0gUmVhY3RfX2RlZmF1bHQubGF6eSAmJiBSZWFjdF9fZGVmYXVsdC5sYXp5KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG51bGw7XG59KS4kJHR5cGVvZjtcbnZhciBGb3J3YXJkVHlwZSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYgJiYgUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBudWxsO1xufSkuJCR0eXBlb2Y7XG5cbnZhciBDT05URVhUX0NVUlJFTlRfVkFMVUUgPSAnX2N1cnJlbnRWYWx1ZSc7XG5cbnZhciBpc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKF9yZWYyKSB7XG4gIHZhciB0eXBlID0gX3JlZjIudHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0eXBlKSkgPT09ICdvYmplY3QnICYmICckJHR5cGVvZicgaW4gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBDb25zdW1lclR5cGUgJiYgQ29uc3VtZXJUeXBlO1xufTtcbnZhciBpc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0eXBlKSkgPT09ICdvYmplY3QnICYmICckJHR5cGVvZicgaW4gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBQcm92aWRlclR5cGUgJiYgUHJvdmlkZXJUeXBlO1xufTtcbnZhciBpc01lbW9UeXBlID0gZnVuY3Rpb24gaXNNZW1vVHlwZShfcmVmNCkge1xuICB2YXIgdHlwZSA9IF9yZWY0LnR5cGU7XG4gIHJldHVybiB0eXBlICYmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHlwZSkpID09PSAnb2JqZWN0JyAmJiAnJCR0eXBlb2YnIGluIHR5cGUgJiYgdHlwZS4kJHR5cGVvZiA9PT0gTWVtb1R5cGUgJiYgTWVtb1R5cGU7XG59O1xudmFyIGlzTGF6eVR5cGUgPSBmdW5jdGlvbiBpc0xhenlUeXBlKF9yZWY1KSB7XG4gIHZhciB0eXBlID0gX3JlZjUudHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0eXBlKSkgPT09ICdvYmplY3QnICYmICckJHR5cGVvZicgaW4gdHlwZSAmJiB0eXBlLiQkdHlwZW9mID09PSBMYXp5VHlwZSAmJiBMYXp5VHlwZTtcbn07XG52YXIgaXNGb3J3YXJkVHlwZSA9IGZ1bmN0aW9uIGlzRm9yd2FyZFR5cGUoX3JlZjYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNi50eXBlO1xuICByZXR1cm4gdHlwZSAmJiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHR5cGUpKSA9PT0gJ29iamVjdCcgJiYgJyQkdHlwZW9mJyBpbiB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IEZvcndhcmRUeXBlICYmIEZvcndhcmRUeXBlO1xufTtcbnZhciBpc0NvbnRleHRUeXBlID0gZnVuY3Rpb24gaXNDb250ZXh0VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc0NvbnRleHRDb25zdW1lcih0eXBlKSB8fCBpc0NvbnRleHRQcm92aWRlcih0eXBlKTtcbn07XG5cbnZhciBnZXRDb250ZXh0UHJvdmlkZXIgPSBmdW5jdGlvbiBnZXRDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICByZXR1cm4gdHlwZSAmJiB0eXBlLl9jb250ZXh0O1xufTtcblxudmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gIC8vIExvZyBsZXZlbFxuICBsb2dMZXZlbDogJ2Vycm9yJyxcblxuICAvLyBBbGxvd3MgdXNpbmcgU0ZDIHdpdGhvdXQgY2hhbmdlc1xuICBwdXJlU0ZDOiB0cnVlLFxuXG4gIC8vIGtlZXAgcmVuZGVyIG1ldGhvZCB1bnBhdGNoZWQsIG1vdmluZyBzaWRlRWZmZWN0IHRvIGNvbXBvbmVudERpZFVwZGF0ZVxuICBwdXJlUmVuZGVyOiB0cnVlLFxuXG4gIC8vIEFsbG93cyBTRkMgdG8gYmUgdXNlZCwgZW5hYmxlcyBcImludGVybWVkaWF0ZVwiIGNvbXBvbmVudHMgdXNlZCBieSBSZWxheSwgc2hvdWxkIGJlIGRpc2FibGVkIGZvciBQcmVhY3RcbiAgYWxsb3dTRkM6IHRydWUsXG5cbiAgLy8gQWxsb3cgaG90IHJlbG9hZCBvZiBlZmZlY3QgaG9va3NcbiAgcmVsb2FkSG9va3M6IHRydWUsXG5cbiAgLy8gRGlzYWJsZSBcImhvdC1yZXBsYWNlbWVudC1yZW5kZXJcIlxuICBkaXNhYmxlSG90UmVuZGVyZXI6IGZhbHNlLFxuXG4gIC8vIERpc2FibGUgXCJob3QtcmVwbGFjZW1lbnQtcmVuZGVyXCIgd2hlbiBpbmplY3Rpb24gaW50byByZWFjdC1kb20gaXMgbWFkZVxuICBkaXNhYmxlSG90UmVuZGVyZXJXaGVuSW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIC8vIENvbnRyb2xzIGByZWFjdC3wn5SlLWRvbSBwYXRjaGAgbm90aWZpY2F0aW9uXG4gIHNob3dSZWFjdERvbVBhdGNoTm90aWZpY2F0aW9uOiB0cnVlLFxuXG4gIC8vIEhvb2sgb24gYmFiZWwgY29tcG9uZW50IHJlZ2lzdGVyLlxuICBvbkNvbXBvbmVudFJlZ2lzdGVyOiBmYWxzZSxcblxuICAvLyBIb29rIG9uIFJlYWN0IHJlbmRlcnMgZm9yIGEgZmlyc3QgdGltZSBjb21wb25lbnRcbiAgb25Db21wb25lbnRDcmVhdGU6IGZhbHNlLFxuXG4gIC8vIGZsYWcgdG8gY29tcGxldGVseSBkaXNhYmxlIFJITCBmb3IgU0ZDLiBQcm9iYWJseSBkb24ndCB1c2UgaXQgd2l0aG91dCBkb20gcGF0Y2ggbWFkZS5cbiAgaWdub3JlU0ZDOiBmYWxzZSxcblxuICAvLyBpZ25vcmVTRkMgd2hlbiBpbmplY3Rpb24gaW50byByZWFjdC1kb20gaXMgbWFkZVxuICBpZ25vcmVTRkNXaGVuSW5qZWN0ZWQ6IHRydWUsXG5cbiAgLy8gZmxhZyB0byBjb21wbGV0ZWx5IGRpc2FibGUgUkhMIGZvciBDb21wb25lbnRzXG4gIGlnbm9yZUNvbXBvbmVudHM6IGZhbHNlLFxuXG4gIC8vIGRlZmF1bHQgdmFsdWUgZm9yIEFwcENvbnRhaW5lciBlcnJvck92ZXJsYXlcbiAgZXJyb3JSZXBvcnRlcjogdW5kZWZpbmVkLFxuXG4gIC8vIEdsb2JhbCBlcnJvciBvdmVybGF5XG4gIEVycm9yT3ZlcmxheTogdW5kZWZpbmVkXG59O1xuXG52YXIgaW50ZXJuYWxDb25maWd1cmF0aW9uID0ge1xuICAvLyBjb250cm9sIHByb3h5IGNyZWF0aW9uXG4gIGRpc2FibGVQcm94eUNyZWF0aW9uOiBmYWxzZVxufTtcblxudmFyIHNldENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiBzZXRDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICAvLyBub3QgdXNpbmcgT2JqZWN0LmFzc2luZyBmb3IgSUUxMSBjb21wbGlhbmNlXG4gIGZvciAodmFyIGkgaW4gY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgY29uZmlndXJhdGlvbltpXSA9IGNvbmZpZ1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblxudmFyIGxvZ2dlciA9IHtcbiAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIGlmIChbJ2RlYnVnJ10uaW5kZXhPZihjb25maWd1cmF0aW9uLmxvZ0xldmVsKSAhPT0gLTEpIHtcbiAgICAgIHZhciBfY29uc29sZTtcblxuICAgICAgKF9jb25zb2xlID0gY29uc29sZSkuZGVidWcuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LFxuICBsb2c6IGZ1bmN0aW9uIGxvZygpIHtcbiAgICBpZiAoWydkZWJ1ZycsICdsb2cnXS5pbmRleE9mKGNvbmZpZ3VyYXRpb24ubG9nTGV2ZWwpICE9PSAtMSkge1xuICAgICAgdmFyIF9jb25zb2xlMjtcblxuICAgICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZTIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LFxuICB3YXJuOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgIGlmIChbJ2RlYnVnJywgJ2xvZycsICd3YXJuJ10uaW5kZXhPZihjb25maWd1cmF0aW9uLmxvZ0xldmVsKSAhPT0gLTEpIHtcbiAgICAgIHZhciBfY29uc29sZTM7XG5cbiAgICAgIChfY29uc29sZTMgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlMywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICBpZiAoWydkZWJ1ZycsICdsb2cnLCAnd2FybicsICdlcnJvciddLmluZGV4T2YoY29uZmlndXJhdGlvbi5sb2dMZXZlbCkgIT09IC0xKSB7XG4gICAgICB2YXIgX2NvbnNvbGU0O1xuXG4gICAgICAoX2NvbnNvbGU0ID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGU0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tZXZhbCwgZnVuYy1uYW1lcyAqL1xuXG5mdW5jdGlvbiBzYWZlUmVhY3RDb25zdHJ1Y3RvcihDb21wb25lbnQsIGxhc3RJbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGlmIChsYXN0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KGxhc3RJbnN0YW5jZS5wcm9wcywgbGFzdEluc3RhbmNlLmNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXBvbmVudCh7fSwge30pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc29tZSBjb21wb25lbnRzLCBsaWtlIFJlZHV4IGNvbm5lY3QgY291bGQgbm90IGJlIGNyZWF0ZWQgd2l0aG91dCBwcm9wZXIgY29udGV4dFxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbi50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA+IDAgOiBmYWxzZTtcbn1cblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoYSkge1xuICByZXR1cm4gYTtcbn07XG52YXIgaW5kaXJlY3RFdmFsID0gZXZhbDtcblxudmFyIGRvZXNTdXBwb3J0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBpbmRpcmVjdEV2YWwoJ2NsYXNzIFRlc3Qge30nKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xuXG52YXIgRVM2UHJveHlDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gRVM2UHJveHlDb21wb25lbnRGYWN0b3J5KEluaXRpYWxQYXJlbnQsIHBvc3RDb25zdHJ1Y3Rpb25BY3Rpb24pIHtcbiAgcmV0dXJuIGluZGlyZWN0RXZhbCgnXFxuKGZ1bmN0aW9uKEluaXRpYWxQYXJlbnQsIHBvc3RDb25zdHJ1Y3Rpb25BY3Rpb24pIHtcXG4gIHJldHVybiBjbGFzcyAnICsgKEluaXRpYWxQYXJlbnQubmFtZSB8fCAnSG90Q29tcG9uZW50JykgKyAnIGV4dGVuZHMgSW5pdGlhbFBhcmVudCB7XFxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XFxuICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXFxuICAgICAgcG9zdENvbnN0cnVjdGlvbkFjdGlvbi5jYWxsKHRoaXMpXFxuICAgIH1cXG4gIH1cXG59KVxcbicpKEluaXRpYWxQYXJlbnQsIHBvc3RDb25zdHJ1Y3Rpb25BY3Rpb24pO1xufTtcblxudmFyIEVTNVByb3h5Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIEVTNVByb3h5Q29tcG9uZW50RmFjdG9yeShJbml0aWFsUGFyZW50LCBwb3N0Q29uc3RydWN0aW9uQWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFByb3h5Q29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG4gICAgSW5pdGlhbFBhcmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICBwb3N0Q29uc3RydWN0aW9uQWN0aW9uLmNhbGwodGhpcyk7XG4gIH1cbiAgUHJveHlDb21wb25lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbml0aWFsUGFyZW50LnByb3RvdHlwZSk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihQcm94eUNvbXBvbmVudCwgSW5pdGlhbFBhcmVudCk7XG4gIHJldHVybiBQcm94eUNvbXBvbmVudDtcbn07XG5cbnZhciBwcm94eUNsYXNzQ3JlYXRvciA9IGRvZXNTdXBwb3J0Q2xhc3NlcyA/IEVTNlByb3h5Q29tcG9uZW50RmFjdG9yeSA6IEVTNVByb3h5Q29tcG9uZW50RmFjdG9yeTtcblxuZnVuY3Rpb24gZ2V0T3duS2V5cyh0YXJnZXQpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93U3RyaW5nc0VxdWFsKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICBpZiAoU3RyaW5nKGFba2V5XSkgIT09IFN0cmluZyhiW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWVwUHJvdG90eXBlVXBkYXRlKGRlc3QsIHNvdXJjZSkge1xuICB2YXIgZGVlcERlc3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZGVzdCk7XG4gIHZhciBkZWVwU3JjID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gIGlmIChkZWVwRGVzdCAmJiBkZWVwU3JjICYmIGRlZXBTcmMgIT09IGRlZXBEZXN0KSB7XG4gICAgZGVlcFByb3RvdHlwZVVwZGF0ZShkZWVwRGVzdCwgZGVlcFNyYyk7XG4gIH1cbiAgaWYgKHNvdXJjZS5wcm90b3R5cGUgJiYgc291cmNlLnByb3RvdHlwZSAhPT0gZGVzdC5wcm90b3R5cGUpIHtcbiAgICBkZXN0LnByb3RvdHlwZSA9IHNvdXJjZS5wcm90b3R5cGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBwcm9wcykge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgcHJvcHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0Vycm9yIHdoaWxlIHdyYXBwaW5nJywga2V5LCAnIC0+ICcsIGUpO1xuICB9XG59XG5cbnZhciBQUkVGSVggPSAnX19yZWFjdHN0YW5kaW5fXyc7XG52YXIgUFJPWFlfS0VZID0gUFJFRklYICsgJ2tleSc7XG52YXIgR0VORVJBVElPTiA9IFBSRUZJWCArICdwcm94eUdlbmVyYXRpb24nO1xudmFyIFJFR0VORVJBVEVfTUVUSE9EID0gUFJFRklYICsgJ3JlZ2VuZXJhdGVCeUV2YWwnO1xudmFyIFVOV1JBUF9QUk9YWSA9IFBSRUZJWCArICdnZXRDdXJyZW50JztcbnZhciBDQUNIRURfUkVTVUxUID0gUFJFRklYICsgJ2NhY2hlZFJlc3VsdCc7XG52YXIgUFJPWFlfSVNfTU9VTlRFRCA9IFBSRUZJWCArICdpc01vdW50ZWQnO1xuXG52YXIgUkVOREVSRURfR0VORVJBVElPTiA9ICdSRUFDVF9IT1RfTE9BREVSX1JFTkRFUkVEX0dFTkVSQVRJT04nO1xuXG52YXIgUkVTRVJWRURfU1RBVElDUyA9IFsnbGVuZ3RoJywgJ2Rpc3BsYXlOYW1lJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2NhbGxlcicsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnLCAndmFsdWVPZicsICdpc1N0YXRlbGVzc0Z1bmN0aW9uYWxQcm94eScsIFBST1hZX0tFWSwgVU5XUkFQX1BST1hZXTtcblxuZnVuY3Rpb24gdHJhbnNmZXJTdGF0aWNQcm9wcyhQcm94eUNvbXBvbmVudCwgc2F2ZWREZXNjcmlwdG9ycywgUHJldmlvdXNDb21wb25lbnQsIE5leHRDb21wb25lbnQpIHtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoUHJveHlDb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChSRVNFUlZFRF9TVEFUSUNTLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFByb3h5Q29tcG9uZW50LCBrZXkpO1xuICAgIHZhciBzYXZlZERlc2NyaXB0b3IgPSBzYXZlZERlc2NyaXB0b3JzW2tleV07XG5cbiAgICBpZiAoIXNoYWxsb3dFcXVhbChwcmV2RGVzY3JpcHRvciwgc2F2ZWREZXNjcmlwdG9yKSkge1xuICAgICAgc2FmZURlZmluZVByb3BlcnR5KE5leHRDb21wb25lbnQsIGtleSwgcHJldkRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29weSBuZXdseSBkZWZpbmVkIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE5leHRDb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChSRVNFUlZFRF9TVEFUSUNTLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSBQcmV2aW91c0NvbXBvbmVudCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFByb3h5Q29tcG9uZW50LCBrZXkpO1xuICAgIHZhciBzYXZlZERlc2NyaXB0b3IgPSBzYXZlZERlc2NyaXB0b3JzW2tleV07XG5cbiAgICAvLyBTa2lwIHJlZGVmaW5lZCBkZXNjcmlwdG9yc1xuICAgIGlmIChwcmV2RGVzY3JpcHRvciAmJiBzYXZlZERlc2NyaXB0b3IgJiYgIXNoYWxsb3dFcXVhbChzYXZlZERlc2NyaXB0b3IsIHByZXZEZXNjcmlwdG9yKSkge1xuICAgICAgc2FmZURlZmluZVByb3BlcnR5KE5leHRDb21wb25lbnQsIGtleSwgcHJldkRlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmV2RGVzY3JpcHRvciAmJiAhc2F2ZWREZXNjcmlwdG9yKSB7XG4gICAgICBzYWZlRGVmaW5lUHJvcGVydHkoUHJveHlDb21wb25lbnQsIGtleSwgcHJldkRlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0RGVzY3JpcHRvciA9IF9leHRlbmRzKHt9LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5leHRDb21wb25lbnQsIGtleSksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgc2F2ZWREZXNjcmlwdG9yc1trZXldID0gbmV4dERlc2NyaXB0b3I7XG4gICAgc2FmZURlZmluZVByb3BlcnR5KFByb3h5Q29tcG9uZW50LCBrZXksIG5leHREZXNjcmlwdG9yKTtcbiAgfSk7XG5cbiAgLy8gUmVtb3ZlIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWZpbmVkXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFByb3h5Q29tcG9uZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoUkVTRVJWRURfU1RBVElDUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNraXAgc3RhdGljcyB0aGF0IGV4aXN0IG9uIHRoZSBuZXh0IGNsYXNzXG4gICAgaWYgKE5leHRDb21wb25lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTa2lwIG5vbi1jb25maWd1cmFibGUgc3RhdGljc1xuICAgIHZhciBwcm94eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFByb3h5Q29tcG9uZW50LCBrZXkpO1xuICAgIGlmIChwcm94eURlc2NyaXB0b3IgJiYgIXByb3h5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSBQcmV2aW91c0NvbXBvbmVudCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFByZXZpb3VzQ29tcG9uZW50LCBrZXkpO1xuICAgIHZhciBzYXZlZERlc2NyaXB0b3IgPSBzYXZlZERlc2NyaXB0b3JzW2tleV07XG5cbiAgICAvLyBTa2lwIHJlZGVmaW5lZCBkZXNjcmlwdG9yc1xuICAgIGlmIChwcmV2RGVzY3JpcHRvciAmJiBzYXZlZERlc2NyaXB0b3IgJiYgIXNoYWxsb3dFcXVhbChzYXZlZERlc2NyaXB0b3IsIHByZXZEZXNjcmlwdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNhZmVEZWZpbmVQcm9wZXJ0eShQcm94eUNvbXBvbmVudCwga2V5LCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzYXZlZERlc2NyaXB0b3JzO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMoUHJveHlDb21wb25lbnQsIE5leHRDb21wb25lbnQsIEluaXRpYWxDb21wb25lbnQsIGxhc3RJbnN0YW5jZSwgaW5qZWN0ZWRNZW1iZXJzKSB7XG4gIHZhciBpbmplY3RlZENvZGUgPSB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgbmV4dEluc3RhbmNlID0gc2FmZVJlYWN0Q29uc3RydWN0b3IoTmV4dENvbXBvbmVudCwgbGFzdEluc3RhbmNlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBCeXBhc3MgYmFiZWwgY2xhc3MgaW5oZXJpdGFuY2UgY2hlY2tpbmdcbiAgICAgIGRlZXBQcm90b3R5cGVVcGRhdGUoSW5pdGlhbENvbXBvbmVudCwgTmV4dENvbXBvbmVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSXQgd2FzIEVTNiBjbGFzc1xuICAgIH1cblxuICAgIHZhciBwcm94eUluc3RhbmNlID0gc2FmZVJlYWN0Q29uc3RydWN0b3IoUHJveHlDb21wb25lbnQsIGxhc3RJbnN0YW5jZSk7XG5cbiAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhcHJveHlJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGluamVjdGVkQ29kZTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VkQXR0cnMgPSBfZXh0ZW5kcyh7fSwgcHJveHlJbnN0YW5jZSwgbmV4dEluc3RhbmNlKTtcbiAgICB2YXIgaGFzUmVnZW5lcmF0ZSA9IHByb3h5SW5zdGFuY2VbUkVHRU5FUkFURV9NRVRIT0RdO1xuICAgIHZhciBvd25LZXlzID0gZ2V0T3duS2V5cyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJveHlDb21wb25lbnQucHJvdG90eXBlKSk7XG4gICAgT2JqZWN0LmtleXMobWVyZ2VkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleS5pbmRleE9mKFBSRUZJWCkgPT09IDApIHJldHVybjtcbiAgICAgIHZhciBuZXh0QXR0ciA9IG5leHRJbnN0YW5jZVtrZXldO1xuICAgICAgdmFyIHByZXZBdHRyID0gcHJveHlJbnN0YW5jZVtrZXldO1xuICAgICAgaWYgKG5leHRBdHRyKSB7XG4gICAgICAgIGlmIChpc05hdGl2ZUZ1bmN0aW9uKG5leHRBdHRyKSB8fCBpc05hdGl2ZUZ1bmN0aW9uKHByZXZBdHRyKSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYm91bmQgbWV0aG9kXG4gICAgICAgICAgdmFyIGlzU2FtZUFyaXR5ID0gbmV4dEF0dHIubGVuZ3RoID09PSBwcmV2QXR0ci5sZW5ndGg7XG4gICAgICAgICAgdmFyIGV4aXN0c0luUHJvdG90eXBlID0gb3duS2V5cy5pbmRleE9mKGtleSkgPj0gMCB8fCBQcm94eUNvbXBvbmVudC5wcm90b3R5cGVba2V5XTtcbiAgICAgICAgICBpZiAoKGlzU2FtZUFyaXR5IHx8ICFwcmV2QXR0cikgJiYgZXhpc3RzSW5Qcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNSZWdlbmVyYXRlKSB7XG4gICAgICAgICAgICAgIGluamVjdGVkQ29kZVtrZXldID0gJ09iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKVtcXCcnICsga2V5ICsgJ1xcJ10uYmluZCh0aGlzKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignUmVhY3QgSG90IExvYWRlcjosJywgJ05vbi1jb250cm9sbGVkIGNsYXNzJywgUHJveHlDb21wb25lbnQubmFtZSwgJ2NvbnRhaW5zIGEgbmV3IG5hdGl2ZSBvciBib3VuZCBmdW5jdGlvbiAnLCBrZXksIG5leHRBdHRyLCAnLiBVbmFibGUgdG8gcmVwcm9kdWNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdSZWFjdCBIb3QgTG9hZGVyOicsICdVcGRhdGVkIGNsYXNzICcsIFByb3h5Q29tcG9uZW50Lm5hbWUsICdjb250YWlucyBuYXRpdmUgb3IgYm91bmQgZnVuY3Rpb24gJywga2V5LCBuZXh0QXR0ciwgJy4gVW5hYmxlIHRvIHJlcHJvZHVjZSwgdXNlIGFycm93IGZ1bmN0aW9ucyBpbnN0ZWFkLicsICcoYXJpdHk6ICcgKyBuZXh0QXR0ci5sZW5ndGggKyAnLycgKyBwcmV2QXR0ci5sZW5ndGggKyAnLCBwcm90bzogJyArIChleGlzdHNJblByb3RvdHlwZSA/ICd5ZXMnIDogJ25vJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dFN0cmluZyA9IFN0cmluZyhuZXh0QXR0cik7XG4gICAgICAgIHZhciBpbmplY3RlZEJlZm9yZSA9IGluamVjdGVkTWVtYmVyc1trZXldO1xuICAgICAgICB2YXIgaXNBcnJvdyA9IG5leHRTdHJpbmcuaW5kZXhPZignPT4nKSA+PSAwO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IG5leHRTdHJpbmcuaW5kZXhPZignZnVuY3Rpb24nKSA+PSAwIHx8IGlzQXJyb3c7XG4gICAgICAgIHZhciByZWZlclRvVGhpcyA9IG5leHRTdHJpbmcuaW5kZXhPZigndGhpcycpID49IDA7XG4gICAgICAgIGlmIChuZXh0U3RyaW5nICE9PSBTdHJpbmcocHJldkF0dHIpIHx8IGluamVjdGVkQmVmb3JlICYmIG5leHRTdHJpbmcgIT09IFN0cmluZyhpbmplY3RlZEJlZm9yZSkgfHwgaXNBcnJvdyAmJiByZWZlclRvVGhpcykge1xuICAgICAgICAgIGlmICghaGFzUmVnZW5lcmF0ZSkge1xuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIGp1c3QgY29weSBwcm9wIG92ZXJcbiAgICAgICAgICAgICAgaW5qZWN0ZWRDb2RlW2tleV0gPSBuZXh0QXR0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdSZWFjdCBIb3QgTG9hZGVyOicsICcgVXBkYXRlZCBjbGFzcyAnLCBQcm94eUNvbXBvbmVudC5uYW1lLCAnaGFkIGRpZmZlcmVudCBjb2RlIGZvcicsIGtleSwgbmV4dEF0dHIsICcuIFVuYWJsZSB0byByZXByb2R1Y2UuIFJlZ2VuZXJhdGlvbiBzdXBwb3J0IG5lZWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5qZWN0ZWRDb2RlW2tleV0gPSBuZXh0QXR0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci53YXJuKCdSZWFjdCBIb3QgTG9hZGVyOicsIGUpO1xuICB9XG4gIHJldHVybiBpbmplY3RlZENvZGU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrTGlmZUN5Y2xlTWV0aG9kcyhQcm94eUNvbXBvbmVudCwgTmV4dENvbXBvbmVudCkge1xuICB0cnkge1xuICAgIHZhciBwMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihQcm94eUNvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgIHZhciBwMiA9IE5leHRDb21wb25lbnQucHJvdG90eXBlO1xuICAgIHJlYWN0TGlmZUN5Y2xlTW91bnRNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwMSwga2V5KSB8fCB7IHZhbHVlOiBwMVtrZXldIH07XG4gICAgICB2YXIgZDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAyLCBrZXkpIHx8IHsgdmFsdWU6IHAyW2tleV0gfTtcbiAgICAgIGlmICghc2hhbGxvd1N0cmluZ3NFcXVhbChkMSwgZDIpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdSZWFjdCBIb3QgTG9hZGVyOicsICdZb3UgZGlkIHVwZGF0ZScsIFByb3h5Q29tcG9uZW50Lm5hbWUsICdzIGxpZmVjeWNsZSBtZXRob2QnLCBrZXksICcuIFVuYWJsZSB0byByZXBlYXQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmplY3QodGFyZ2V0LCBjdXJyZW50R2VuZXJhdGlvbiwgaW5qZWN0ZWRNZW1iZXJzKSB7XG4gIGlmICh0YXJnZXRbR0VORVJBVElPTl0gIT09IGN1cnJlbnRHZW5lcmF0aW9uKSB7XG4gICAgdmFyIGhhc1JlZ2VuZXJhdGUgPSAhIXRhcmdldFtSRUdFTkVSQVRFX01FVEhPRF07XG4gICAgT2JqZWN0LmtleXMoaW5qZWN0ZWRNZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYXNSZWdlbmVyYXRlKSB7XG4gICAgICAgICAgdmFyIHVzZWRUaGlzID0gU3RyaW5nKGluamVjdGVkTWVtYmVyc1trZXldKS5tYXRjaCgvX3RoaXMoW1xcZF0rKS9naSkgfHwgW107XG4gICAgICAgICAgdGFyZ2V0W1JFR0VORVJBVEVfTUVUSE9EXShrZXksICcoZnVuY3Rpb24gUkVBQ1RfSE9UX0xPQURFUl9TQU5EQk9YICgpIHtcXG4gICAgICAgICAgdmFyIF90aGlzICA9IHRoaXM7IC8vIGNvbW1vbiBiYWJlbCB0cmFuc3BpbGVcXG4gICAgICAgICAgJyArIHVzZWRUaGlzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICd2YXIgJyArIG5hbWUgKyAnID0gdGhpczsnO1xuICAgICAgICAgIH0pICsgJ1xcblxcbiAgICAgICAgICByZXR1cm4gJyArIGluamVjdGVkTWVtYmVyc1trZXldICsgJztcXG4gICAgICAgICAgfSkuY2FsbCh0aGlzKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gaW5qZWN0ZWRNZW1iZXJzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1JlYWN0IEhvdCBMb2FkZXI6IEZhaWxlZCB0byByZWdlbmVyYXRlIG1ldGhvZCAnLCBrZXksICcgb2YgY2xhc3MgJywgdGFyZ2V0KTtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2dvdCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0W0dFTkVSQVRJT05dID0gY3VycmVudEdlbmVyYXRpb247XG4gIH1cbn1cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBwcm94aWVzID0gbmV3IFdlYWtNYXAoKTtcblxudmFyIHJlc2V0Q2xhc3NQcm94aWVzID0gZnVuY3Rpb24gcmVzZXRDbGFzc1Byb3hpZXMoKSB7XG4gIHByb3hpZXMgPSBuZXcgV2Vha01hcCgpO1xufTtcblxudmFyIGJsYWNrTGlzdGVkQ2xhc3NNZW1iZXJzID0gWydjb25zdHJ1Y3RvcicsICdyZW5kZXInLCAnY29tcG9uZW50V2lsbE1vdW50JywgJ2NvbXBvbmVudERpZE1vdW50JywgJ2NvbXBvbmVudERpZENhdGNoJywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLCAnY29tcG9uZW50V2lsbFVubW91bnQnLCAnaG90Q29tcG9uZW50UmVuZGVyJywgJ2dldEluaXRpYWxTdGF0ZScsICdnZXREZWZhdWx0UHJvcHMnXTtcblxudmFyIGRlZmF1bHRSZW5kZXJPcHRpb25zID0ge1xuICBjb21wb25lbnRXaWxsUmVuZGVyOiBpZGVudGl0eSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgY29tcG9uZW50RGlkUmVuZGVyOiBmdW5jdGlvbiBjb21wb25lbnREaWRSZW5kZXIocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZpbHRlcmVkUHJvdG90eXBlTWV0aG9kcyA9IGZ1bmN0aW9uIGZpbHRlcmVkUHJvdG90eXBlTWV0aG9kcyhQcm90bykge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoUHJvdG8pLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihQcm90bywgcHJvcCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgcHJvcC5pbmRleE9mKFBSRUZJWCkgIT09IDAgJiYgYmxhY2tMaXN0ZWRDbGFzc01lbWJlcnMuaW5kZXhPZihwcm9wKSA8IDAgJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH0pO1xufTtcblxudmFyIGRlZmluZUNsYXNzTWVtYmVyID0gZnVuY3Rpb24gZGVmaW5lQ2xhc3NNZW1iZXIoQ2xhc3MsIG1ldGhvZE5hbWUsIG1ldGhvZEJvZHkpIHtcbiAgcmV0dXJuIHNhZmVEZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IG1ldGhvZEJvZHlcbiAgfSk7XG59O1xuXG52YXIgZGVmaW5lQ2xhc3NNZW1iZXJzID0gZnVuY3Rpb24gZGVmaW5lQ2xhc3NNZW1iZXJzKENsYXNzLCBtZXRob2RzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIGRlZmluZUNsYXNzTWVtYmVyKENsYXNzLCBtZXRob2ROYW1lLCBtZXRob2RzW21ldGhvZE5hbWVdKTtcbiAgfSk7XG59O1xuXG52YXIgc2V0U0ZQRmxhZyA9IGZ1bmN0aW9uIHNldFNGUEZsYWcoY29tcG9uZW50LCBmbGFnKSB7XG4gIHJldHVybiBzYWZlRGVmaW5lUHJvcGVydHkoY29tcG9uZW50LCAnaXNTdGF0ZWxlc3NGdW5jdGlvbmFsUHJveHknLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZsYWdcbiAgfSk7XG59O1xuXG52YXIgY29weU1ldGhvZERlc2NyaXB0b3JzID0gZnVuY3Rpb24gY29weU1ldGhvZERlc2NyaXB0b3JzKHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChzb3VyY2UpIHtcbiAgICAvLyBpdCBpcyBwb3NzaWJsZSB0byB1c2UgYGZ1bmN0aW9uLWRvdWJsZWAgdG8gY29uc3RydWN0IGFuIGlkZWFsIGNsb25lLCBidXQgZG9lcyBub3QgbWFrZSBhIHNlbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpO1xuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBzYWZlRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIHNhZmVEZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICd0b1N0cmluZycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGtub3duQ2xhc3NDb21wb25lbnRzID0gW107XG5cbnZhciBmb3JFYWNoS25vd25DbGFzcyA9IGZ1bmN0aW9uIGZvckVhY2hLbm93bkNsYXNzKGNiKSB7XG4gIHJldHVybiBrbm93bkNsYXNzQ29tcG9uZW50cy5mb3JFYWNoKGNiKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzUHJveHkoSW5pdGlhbENvbXBvbmVudCwgcHJveHlLZXkpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIHZhciByZW5kZXJPcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRSZW5kZXJPcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIHByb3h5Q29uZmlnID0gX2V4dGVuZHMoe30sIGNvbmZpZ3VyYXRpb24sIG9wdGlvbnMucHJveHkpO1xuICAvLyBQcmV2ZW50IGRvdWJsZSB3cmFwcGluZy5cbiAgLy8gR2l2ZW4gYSBwcm94eSBjbGFzcywgcmV0dXJuIHRoZSBleGlzdGluZyBwcm94eSBtYW5hZ2luZyBpdC5cbiAgdmFyIGV4aXN0aW5nUHJveHkgPSBwcm94aWVzLmdldChJbml0aWFsQ29tcG9uZW50KTtcblxuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG5cbiAgdmFyIEN1cnJlbnRDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciBzYXZlZERlc2NyaXB0b3JzID0ge307XG4gIHZhciBpbmplY3RlZE1lbWJlcnMgPSB7fTtcbiAgdmFyIHByb3h5R2VuZXJhdGlvbiA9IDA7XG4gIHZhciBjbGFzc1VwZGF0ZVBvc3Rwb25lZCA9IG51bGw7XG4gIHZhciBpbnN0YW5jZXNDb3VudCA9IDA7XG4gIHZhciBpc0Z1bmN0aW9uYWxDb21wb25lbnQgPSAhaXNSZWFjdENsYXNzKEluaXRpYWxDb21wb25lbnQpO1xuXG4gIHZhciBsYXN0SW5zdGFuY2UgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHBvc3RDb25zdHJ1Y3Rpb25BY3Rpb24oKSB7XG4gICAgdGhpc1tHRU5FUkFUSU9OXSA9IDA7XG5cbiAgICBsYXN0SW5zdGFuY2UgPSB0aGlzO1xuICAgIC8vIGlzIHRoZXJlIGlzIGFuIHVwZGF0ZSBwZW5kaW5nXG4gICAgaWYgKGNsYXNzVXBkYXRlUG9zdHBvbmVkKSB7XG4gICAgICB2YXIgY2FsbFVwZGF0ZSA9IGNsYXNzVXBkYXRlUG9zdHBvbmVkO1xuICAgICAgY2xhc3NVcGRhdGVQb3N0cG9uZWQgPSBudWxsO1xuICAgICAgY2FsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICAvLyBBcyBsb25nIHdlIGNhbid0IG92ZXJyaWRlIGNvbnN0cnVjdG9yXG4gICAgLy8gZXZlcnkgY2xhc3Mgc2hhbGwgZXZvbHZlIGZyb20gYSBiYXNlIGNsYXNzXG4gICAgaW5qZWN0KHRoaXMsIHByb3h5R2VuZXJhdGlvbiwgaW5qZWN0ZWRNZW1iZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3hpZWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgIGluamVjdCh0aGlzLCBwcm94eUdlbmVyYXRpb24sIGluamVjdGVkTWVtYmVycyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlmZUN5Y2xlV3JhcHBlckZhY3Rvcnkod3JhcHBlck5hbWUpIHtcbiAgICB2YXIgc2lkZUVmZmVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogaWRlbnRpdHk7XG5cbiAgICByZXR1cm4gY29weU1ldGhvZERlc2NyaXB0b3JzKGZ1bmN0aW9uIHdyYXBwZWRNZXRob2QoKSB7XG4gICAgICBwcm94aWVkVXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICBzaWRlRWZmZWN0KHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWlzRnVuY3Rpb25hbENvbXBvbmVudCAmJiBDdXJyZW50Q29tcG9uZW50LnByb3RvdHlwZVt3cmFwcGVyTmFtZV0gJiYgQ3VycmVudENvbXBvbmVudC5wcm90b3R5cGVbd3JhcHBlck5hbWVdLmFwcGx5KHRoaXMsIHJlc3QpO1xuICAgIH0sIEluaXRpYWxDb21wb25lbnQucHJvdG90eXBlICYmIEluaXRpYWxDb21wb25lbnQucHJvdG90eXBlW3dyYXBwZXJOYW1lXSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RXcmFwcGVyRmFjdG9yeSh3cmFwcGVyTmFtZSwgcmVhbE1ldGhvZCkge1xuICAgIHJldHVybiBjb3B5TWV0aG9kRGVzY3JpcHRvcnMoZnVuY3Rpb24gd3JhcHBlZE1ldGhvZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHJlc3RbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWxNZXRob2QuYXBwbHkodGhpcywgcmVzdCk7XG4gICAgfSwgcmVhbE1ldGhvZCk7XG4gIH1cblxuICB2YXIgZmFrZUJhc2VQcm90b3R5cGUgPSBmdW5jdGlvbiBmYWtlQmFzZVByb3RvdHlwZShQcm90bykge1xuICAgIHJldHVybiBmaWx0ZXJlZFByb3RvdHlwZU1ldGhvZHMoUHJvdG8pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIGFjY1trZXldID0gbWV0aG9kV3JhcHBlckZhY3Rvcnkoa2V5LCBQcm90b1trZXldKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIHZhciBjb21wb25lbnREaWRNb3VudCA9IGxpZmVDeWNsZVdyYXBwZXJGYWN0b3J5KCdjb21wb25lbnREaWRNb3VudCcsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXRbUFJPWFlfSVNfTU9VTlRFRF0gPSB0cnVlO1xuICAgIHRhcmdldFtSRU5ERVJFRF9HRU5FUkFUSU9OXSA9IGdldCQxKCk7XG4gICAgaW5zdGFuY2VzQ291bnQrKztcbiAgfSk7XG4gIHZhciBjb21wb25lbnREaWRVcGRhdGUgPSBsaWZlQ3ljbGVXcmFwcGVyRmFjdG9yeSgnY29tcG9uZW50RGlkVXBkYXRlJywgcmVuZGVyT3B0aW9ucy5jb21wb25lbnREaWRVcGRhdGUpO1xuICB2YXIgY29tcG9uZW50V2lsbFVubW91bnQgPSBsaWZlQ3ljbGVXcmFwcGVyRmFjdG9yeSgnY29tcG9uZW50V2lsbFVubW91bnQnLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0W1BST1hZX0lTX01PVU5URURdID0gZmFsc2U7XG4gICAgaW5zdGFuY2VzQ291bnQtLTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaG90Q29tcG9uZW50UmVuZGVyKCkge1xuICAgIC8vIHJlcGVhdGluZyBzdWJyZW5kZXIgY2FsbCB0byBrZWVwIFJFTkRFUkVEX0dFTkVSQVRJT04gdXAgdG8gZGF0ZVxuICAgIHJlbmRlck9wdGlvbnMuY29tcG9uZW50V2lsbFJlbmRlcih0aGlzKTtcbiAgICBwcm94aWVkVXBkYXRlLmNhbGwodGhpcyk7XG4gICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcblxuICAgIC8vIFdlIG5lZWQgdG8gdXNlIGhhc093blByb3BlcnR5IGhlcmUsIGFzIHRoZSBjYWNoZWQgcmVzdWx0IGlzIGEgUmVhY3Qgbm9kZVxuICAgIC8vIGFuZCBjYW4gYmUgbnVsbCBvciBzb21lIG90aGVyIGZhbHN5IHZhbHVlLlxuICAgIGlmIChoYXMuY2FsbCh0aGlzLCBDQUNIRURfUkVTVUxUKSkge1xuICAgICAgcmVzdWx0ID0gdGhpc1tDQUNIRURfUkVTVUxUXTtcbiAgICAgIGRlbGV0ZSB0aGlzW0NBQ0hFRF9SRVNVTFRdO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbmFsQ29tcG9uZW50KSB7XG4gICAgICByZXN1bHQgPSBDdXJyZW50Q29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZW5kZXJNZXRob2QgPSBDdXJyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgfHwgdGhpcy5yZW5kZXI7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICAgICAgaWYgKHJlbmRlck1ldGhvZCA9PT0gcHJveGllZFJlbmRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LUhvdC1Mb2FkZXI6IHlvdSBhcmUgdHJ5aW5nIHRvIHJlbmRlciBDb21wb25lbnQgd2l0aG91dCAucmVuZGVyIG1ldGhvZCcpO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgcmVzdWx0ID0gcmVuZGVyTWV0aG9kLmFwcGx5KHRoaXMsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJPcHRpb25zLmNvbXBvbmVudERpZFJlbmRlci5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBob3RDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgcmVuZGVyT3B0aW9ucy5jb21wb25lbnRXaWxsUmVuZGVyKHRoaXMpO1xuICAgIHByb3hpZWRVcGRhdGUuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3hpZWRSZW5kZXIoKSB7XG4gICAgcmVuZGVyT3B0aW9ucy5jb21wb25lbnRXaWxsUmVuZGVyKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG90Q29tcG9uZW50UmVuZGVyLmNhbGwuYXBwbHkoaG90Q29tcG9uZW50UmVuZGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIHZhciBkZWZpbmVQcm94eU1ldGhvZHMgPSBmdW5jdGlvbiBkZWZpbmVQcm94eU1ldGhvZHMoUHJveHkpIHtcbiAgICB2YXIgQmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBkZWZpbmVDbGFzc01lbWJlcnMoUHJveHksIF9leHRlbmRzKHt9LCBmYWtlQmFzZVByb3RvdHlwZShCYXNlKSwgcHJveHlDb25maWcucHVyZVJlbmRlciA/IHt9IDogeyByZW5kZXI6IHByb3hpZWRSZW5kZXIgfSwge1xuICAgICAgaG90Q29tcG9uZW50UmVuZGVyOiBob3RDb21wb25lbnRSZW5kZXIsXG4gICAgICBob3RDb21wb25lbnRVcGRhdGU6IGhvdENvbXBvbmVudFVwZGF0ZSxcbiAgICAgIGNvbXBvbmVudERpZE1vdW50OiBjb21wb25lbnREaWRNb3VudCxcbiAgICAgIGNvbXBvbmVudERpZFVwZGF0ZTogY29tcG9uZW50RGlkVXBkYXRlLFxuICAgICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGNvbXBvbmVudFdpbGxVbm1vdW50XG4gICAgfSkpO1xuICB9O1xuXG4gIHZhciBfUHJveHlGYWNhZGUgPSB2b2lkIDA7XG4gIHZhciBQcm94eUNvbXBvbmVudCA9IG51bGw7XG4gIHZhciBwcm94eSA9IHZvaWQgMDtcblxuICBpZiAoIWlzRnVuY3Rpb25hbENvbXBvbmVudCkge1xuICAgIC8vIENvbXBvbmVudFxuICAgIFByb3h5Q29tcG9uZW50ID0gcHJveHlDbGFzc0NyZWF0b3IoSW5pdGlhbENvbXBvbmVudCwgcG9zdENvbnN0cnVjdGlvbkFjdGlvbik7XG5cbiAgICBkZWZpbmVQcm94eU1ldGhvZHMoUHJveHlDb21wb25lbnQsIEluaXRpYWxDb21wb25lbnQucHJvdG90eXBlKTtcblxuICAgIGtub3duQ2xhc3NDb21wb25lbnRzLnB1c2goUHJveHlDb21wb25lbnQpO1xuXG4gICAgX1Byb3h5RmFjYWRlID0gUHJveHlDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoIXByb3h5Q29uZmlnLmFsbG93U0ZDKSB7XG4gICAgcHJveHlDb25maWcucHVyZVJlbmRlciA9IGZhbHNlO1xuICAgIC8vIFNGQyBDb252ZXJ0ZWQgdG8gY29tcG9uZW50LiBEb2VzIG5vdCBzdXBwb3J0IHJldHVybmluZyBwcmVjcmVhdGVkIGluc3RhbmNlcyBmcm9tIHJlbmRlci5cbiAgICBQcm94eUNvbXBvbmVudCA9IHByb3h5Q2xhc3NDcmVhdG9yKFJlYWN0LkNvbXBvbmVudCwgcG9zdENvbnN0cnVjdGlvbkFjdGlvbik7XG5cbiAgICBkZWZpbmVQcm94eU1ldGhvZHMoUHJveHlDb21wb25lbnQpO1xuICAgIF9Qcm94eUZhY2FkZSA9IFByb3h5Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIFNGQ1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBvbmx5IGdldHMgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCBtb3VudC4gVGhlIGFjdHVhbFxuICAgIC8vIHJlbmRlcmVkIGNvbXBvbmVudCBpbnN0YW5jZSB3aWxsIGJlIHRoZSByZXR1cm4gdmFsdWUuXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIF9Qcm94eUZhY2FkZSA9IGZ1bmN0aW9uIFByb3h5RmFjYWRlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gQ3VycmVudENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBSZWxheS1zdHlsZSBjb250YWluZXIgY29uc3RydWN0b3IuIFdlIGNhbid0IGRvIHRoZSBwcm90b3R5cGUtXG4gICAgICAvLyBzdHlsZSB3cmFwcGluZyBmb3IgdGhpcyBhcyB3ZSBkbyBlbHNld2hlcmUsIHNvIGp1c3Qgd2UganVzdCBwYXNzIGl0XG4gICAgICAvLyB0aHJvdWdoIGFzLWlzLlxuICAgICAgaWYgKGlzUmVhY3RDbGFzc0luc3RhbmNlKHJlc3VsdCkpIHtcbiAgICAgICAgUHJveHlDb21wb25lbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIFJlbGF5IGxhemlseSBzZXRzIHN0YXRpY3MgbGlrZSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgb24gaW5pdGlhbFxuICAgICAgICAvLyByZW5kZXIgaW4gbGF6eSBjb25zdHJ1Y3Rpb24sIHNvIHdlIG5lZWQgdG8gZG8gdGhlIHNhbWUgaGVyZS5cbiAgICAgICAgdHJhbnNmZXJTdGF0aWNQcm9wcyhfUHJveHlGYWNhZGUsIHNhdmVkRGVzY3JpcHRvcnMsIG51bGwsIEN1cnJlbnRDb21wb25lbnQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpbXBsZSBTRkMsIGNvdWxkIGNvbnRpbnVlIHRvIGJlIFNGQ1xuICAgICAgaWYgKHByb3h5Q29uZmlnLnB1cmVTRkMpIHtcbiAgICAgICAgaWYgKCFDdXJyZW50Q29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGlmICghX1Byb3h5RmFjYWRlLmlzU3RhdGVsZXNzRnVuY3Rpb25hbFByb3h5KSB7XG4gICAgICAgICAgICBzZXRTRlBGbGFnKF9Qcm94eUZhY2FkZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlbmRlck9wdGlvbnMuY29tcG9uZW50RGlkUmVuZGVyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFNGUEZsYWcoX1Byb3h5RmFjYWRlLCBmYWxzZSk7XG4gICAgICBwcm94eUNvbmZpZy5wdXJlUmVuZGVyID0gZmFsc2U7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBhIG5vcm1hbCBmdW5jdGlvbmFsIGNvbXBvbmVudC4gQnVpbGQgdGhlIHJlYWwgcHJveHlcbiAgICAgIC8vIGFuZCB1c2UgaXQgZ29pbmcgZm9yd2FyZC5cbiAgICAgIFByb3h5Q29tcG9uZW50ID0gcHJveHlDbGFzc0NyZWF0b3IoUmVhY3QuQ29tcG9uZW50LCBwb3N0Q29uc3RydWN0aW9uQWN0aW9uKTtcblxuICAgICAgZGVmaW5lUHJveHlNZXRob2RzKFByb3h5Q29tcG9uZW50KTtcblxuICAgICAgdmFyIGRldGVybWluYXRlUmVzdWx0ID0gbmV3IFByb3h5Q29tcG9uZW50KHByb3BzLCBjb250ZXh0KTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIGluaXRpYWwgcmVuZGVyIHJlc3VsdCBzbyB3ZSBkb24ndCBjYWxsIHRoZSBjb21wb25lbnQgZnVuY3Rpb25cbiAgICAgIC8vIGEgc2Vjb25kIHRpbWUgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgIGRldGVybWluYXRlUmVzdWx0W0NBQ0hFRF9SRVNVTFRdID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIGRldGVybWluYXRlUmVzdWx0O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIF9Qcm94eUZhY2FkZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRDb21wb25lbnQ7XG4gIH1cblxuICBzYWZlRGVmaW5lUHJvcGVydHkoX1Byb3h5RmFjYWRlLCBVTldSQVBfUFJPWFksIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZ2V0Q3VycmVudFxuICB9KTtcblxuICBzYWZlRGVmaW5lUHJvcGVydHkoX1Byb3h5RmFjYWRlLCBQUk9YWV9LRVksIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogcHJveHlLZXlcbiAgfSk7XG5cbiAgc2FmZURlZmluZVByb3BlcnR5KF9Qcm94eUZhY2FkZSwgJ3RvU3RyaW5nJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhDdXJyZW50Q29tcG9uZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShOZXh0Q29tcG9uZW50KSB7XG4gICAgaWYgKHR5cGVvZiBOZXh0Q29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgY29uc3RydWN0b3IuJyk7XG4gICAgfVxuXG4gICAgaWYgKE5leHRDb21wb25lbnQgPT09IEN1cnJlbnRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHByb3h5IGN5Y2xlc1xuICAgIHZhciBleGlzdGluZ1Byb3h5ID0gcHJveGllcy5nZXQoTmV4dENvbXBvbmVudCk7XG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc0Z1bmN0aW9uYWxDb21wb25lbnQgPSAhaXNSZWFjdENsYXNzKE5leHRDb21wb25lbnQpO1xuXG4gICAgcHJveGllcy5zZXQoTmV4dENvbXBvbmVudCwgcHJveHkpO1xuXG4gICAgcHJveHlHZW5lcmF0aW9uKys7XG5cbiAgICAvLyBTYXZlIHRoZSBuZXh0IGNvbnN0cnVjdG9yIHNvIHdlIGNhbGwgaXRcbiAgICB2YXIgUHJldmlvdXNDb21wb25lbnQgPSBDdXJyZW50Q29tcG9uZW50O1xuICAgIEN1cnJlbnRDb21wb25lbnQgPSBOZXh0Q29tcG9uZW50O1xuXG4gICAgLy8gVHJ5IHRvIGluZmVyIGRpc3BsYXlOYW1lXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUoQ3VycmVudENvbXBvbmVudCk7XG5cbiAgICBzYWZlRGVmaW5lUHJvcGVydHkoX1Byb3h5RmFjYWRlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRpc3BsYXlOYW1lXG4gICAgfSk7XG5cbiAgICBpZiAoUHJveHlDb21wb25lbnQpIHtcbiAgICAgIHNhZmVEZWZpbmVQcm9wZXJ0eShQcm94eUNvbXBvbmVudCwgJ25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBkaXNwbGF5TmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2F2ZWREZXNjcmlwdG9ycyA9IHRyYW5zZmVyU3RhdGljUHJvcHMoX1Byb3h5RmFjYWRlLCBzYXZlZERlc2NyaXB0b3JzLCBQcmV2aW91c0NvbXBvbmVudCwgTmV4dENvbXBvbmVudCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbmFsQ29tcG9uZW50IHx8ICFQcm94eUNvbXBvbmVudCkgOyBlbHNlIHtcbiAgICAgIHZhciBjbGFzc0hvdFJlcGxhY2VtZW50ID0gZnVuY3Rpb24gY2xhc3NIb3RSZXBsYWNlbWVudCgpIHtcbiAgICAgICAgZ2V0RWxlbWVudENsb3NlSG9vayhQcm94eUNvbXBvbmVudCk7XG4gICAgICAgIGNoZWNrTGlmZUN5Y2xlTWV0aG9kcyhQcm94eUNvbXBvbmVudCwgTmV4dENvbXBvbmVudCk7XG4gICAgICAgIGlmIChwcm94eUdlbmVyYXRpb24gPiAxKSB7XG4gICAgICAgICAgZmlsdGVyZWRQcm90b3R5cGVNZXRob2RzKFByb3h5Q29tcG9uZW50LnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFoYXMuY2FsbChOZXh0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIFByb3h5Q29tcG9uZW50LnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUHJveHlDb21wb25lbnQucHJvdG90eXBlLCBOZXh0Q29tcG9uZW50LnByb3RvdHlwZSk7XG4gICAgICAgIGRlZmluZVByb3h5TWV0aG9kcyhQcm94eUNvbXBvbmVudCwgTmV4dENvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgICAgICBpZiAocHJveHlHZW5lcmF0aW9uID4gMSkge1xuICAgICAgICAgIGluamVjdGVkTWVtYmVycyA9IG1lcmdlQ29tcG9uZW50cyhQcm94eUNvbXBvbmVudCwgTmV4dENvbXBvbmVudCwgSW5pdGlhbENvbXBvbmVudCwgbGFzdEluc3RhbmNlLCBpbmplY3RlZE1lbWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGdldEVsZW1lbnRDb21wYXJpc29uSG9vayhQcm94eUNvbXBvbmVudCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBXYXMgY29uc3RydWN0ZWQgb25jZVxuICAgICAgaWYgKGluc3RhbmNlc0NvdW50ID4gMCkge1xuICAgICAgICBjbGFzc0hvdFJlcGxhY2VtZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc1VwZGF0ZVBvc3Rwb25lZCA9IGNsYXNzSG90UmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKEluaXRpYWxDb21wb25lbnQpO1xuXG4gIHZhciBkZXJlZmVyZW5jZSA9IGZ1bmN0aW9uIGRlcmVmZXJlbmNlKCkge1xuICAgIHByb3hpZXMuZGVsZXRlKEluaXRpYWxDb21wb25lbnQpO1xuICAgIHByb3hpZXMuZGVsZXRlKF9Qcm94eUZhY2FkZSk7XG4gICAgcHJveGllcy5kZWxldGUoQ3VycmVudENvbXBvbmVudCk7XG4gIH07XG5cbiAgcHJveHkgPSB7IGdldDogZ2V0JCQxLCB1cGRhdGU6IHVwZGF0ZSwgZGVyZWZlcmVuY2U6IGRlcmVmZXJlbmNlLCBnZXRDdXJyZW50OiBmdW5jdGlvbiBnZXRDdXJyZW50KCkge1xuICAgICAgcmV0dXJuIEN1cnJlbnRDb21wb25lbnQ7XG4gICAgfSB9O1xuXG4gIHByb3hpZXMuc2V0KEluaXRpYWxDb21wb25lbnQsIHByb3h5KTtcbiAgcHJveGllcy5zZXQoX1Byb3h5RmFjYWRlLCBwcm94eSk7XG5cbiAgc2FmZURlZmluZVByb3BlcnR5KHByb3h5LCBVTldSQVBfUFJPWFksIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZ2V0Q3VycmVudFxuICB9KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbi8vIHRoaXMgY291bnRlciB0cmFja3MgYHJlZ2lzdGVyYCBpbnZvY2F0aW9ucy5cbi8vIHdvcmtzIGdvb2QsIGJ1dCBjb2RlIHNwbGl0dGluZyBpcyBicmVha2luZyBpdFxudmFyIGdlbmVyYXRpb24gPSAxO1xuXG4vLyB0aGVzZSBjb3VudGVycyBhcmUgYWltZWQgdG8gbWl0aWdhdGUgdGhlIFwiZmlyc3QgcmVuZGVyXCJcbnZhciBob3RDb21wYXJpc29uQ291bnRlciA9IDA7XG52YXIgaG90Q29tcGFyaXNvblJ1bnMgPSAwO1xudmFyIG51bGxGdW5jdGlvbiA9IGZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHtcbiAgcmV0dXJuIHt9O1xufTtcblxuLy8gdGhlc2UgY2FsbGJhY2tzIHdvdWxkIGJlIGNhbGxlZCBvbiBjb21wb25lbnQgdXBkYXRlXG52YXIgb25Ib3RDb21wYXJpc29uT3BlbiA9IG51bGxGdW5jdGlvbjtcbnZhciBvbkhvdENvbXBhcmlzb25FbGVtZW50ID0gbnVsbEZ1bmN0aW9uO1xudmFyIG9uSG90Q29tcGFyaXNvbkNsb3NlID0gbnVsbEZ1bmN0aW9uO1xuXG4vLyBpbnZlcnNpb24gb2YgY29udHJvbFxudmFyIHNldENvbXBhcmlzb25Ib29rcyA9IGZ1bmN0aW9uIHNldENvbXBhcmlzb25Ib29rcyhvcGVuLCBlbGVtZW50LCBjbG9zZSkge1xuICBvbkhvdENvbXBhcmlzb25PcGVuID0gb3BlbjtcbiAgb25Ib3RDb21wYXJpc29uRWxlbWVudCA9IGVsZW1lbnQ7XG4gIG9uSG90Q29tcGFyaXNvbkNsb3NlID0gY2xvc2U7XG59O1xuXG52YXIgZ2V0RWxlbWVudENvbXBhcmlzb25Ib29rID0gZnVuY3Rpb24gZ2V0RWxlbWVudENvbXBhcmlzb25Ib29rKGNvbXBvbmVudCkge1xuICByZXR1cm4gb25Ib3RDb21wYXJpc29uRWxlbWVudChjb21wb25lbnQpO1xufTtcbnZhciBnZXRFbGVtZW50Q2xvc2VIb29rID0gZnVuY3Rpb24gZ2V0RWxlbWVudENsb3NlSG9vayhjb21wb25lbnQpIHtcbiAgcmV0dXJuIG9uSG90Q29tcGFyaXNvbkNsb3NlKGNvbXBvbmVudCk7XG59O1xuXG52YXIgaG90Q29tcGFyaXNvbk9wZW4gPSBmdW5jdGlvbiBob3RDb21wYXJpc29uT3BlbigpIHtcbiAgcmV0dXJuIGhvdENvbXBhcmlzb25Db3VudGVyID4gMCAmJiBob3RDb21wYXJpc29uUnVucyA+IDA7XG59O1xuXG52YXIgb3BlbkdlbmVyYXRpb24gPSBmdW5jdGlvbiBvcGVuR2VuZXJhdGlvbigpIHtcbiAgcmV0dXJuIGZvckVhY2hLbm93bkNsYXNzKG9uSG90Q29tcGFyaXNvbkVsZW1lbnQpO1xufTtcblxudmFyIGNsb3NlR2VuZXJhdGlvbiA9IGZ1bmN0aW9uIGNsb3NlR2VuZXJhdGlvbigpIHtcbiAgcmV0dXJuIGZvckVhY2hLbm93bkNsYXNzKG9uSG90Q29tcGFyaXNvbkNsb3NlKTtcbn07XG5cbnZhciBpbmNyZW1lbnRIb3QgPSBmdW5jdGlvbiBpbmNyZW1lbnRIb3QoKSB7XG4gIGlmICghaG90Q29tcGFyaXNvbkNvdW50ZXIpIHtcbiAgICBvcGVuR2VuZXJhdGlvbigpO1xuICAgIG9uSG90Q29tcGFyaXNvbk9wZW4oKTtcbiAgfVxuICBob3RDb21wYXJpc29uQ291bnRlcisrO1xufTtcbnZhciBkZWNyZW1lbnRIb3QgPSBmdW5jdGlvbiBkZWNyZW1lbnRIb3QoKSB7XG4gIGhvdENvbXBhcmlzb25Db3VudGVyLS07XG4gIGlmICghaG90Q29tcGFyaXNvbkNvdW50ZXIpIHtcbiAgICBjbG9zZUdlbmVyYXRpb24oKTtcbiAgICBob3RDb21wYXJpc29uUnVucysrO1xuICB9XG59O1xuXG4vLyBUT0RPOiBzaGFsbCBpdCBiZSBjYWxsZWQgZnJvbSBpbmNyZW1lbnRIb3RHZW5lcmF0aW9uP1xudmFyIGVudGVySG90VXBkYXRlID0gZnVuY3Rpb24gZW50ZXJIb3RVcGRhdGUoKSB7XG4gIFByb21pc2UucmVzb2x2ZShpbmNyZW1lbnRIb3QoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZGVjcmVtZW50SG90LCAwKTtcbiAgfSk7XG59O1xuXG4vLyBUT0RPOiBkZXByZWNhdGU/XG52YXIgaW5jcmVtZW50ID0gZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBlbnRlckhvdFVwZGF0ZSgpO1xuICByZXR1cm4gZ2VuZXJhdGlvbisrO1xufTtcbnZhciBnZXQkMSA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgcmV0dXJuIGdlbmVyYXRpb247XG59O1xuXG4vLyBUaGVzZSBjb3VudGVycyB0cmFja3MgSE1SIGdlbmVyYXRpb25zLCBhbmQgcHJvYmFibHkgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgb2xkIG9uZVxudmFyIGhvdFJlcGxhY2VtZW50R2VuZXJhdGlvbiA9IDA7XG52YXIgaW5jcmVtZW50SG90R2VuZXJhdGlvbiA9IGZ1bmN0aW9uIGluY3JlbWVudEhvdEdlbmVyYXRpb24oKSB7XG4gIHJldHVybiBob3RSZXBsYWNlbWVudEdlbmVyYXRpb24rKztcbn07XG52YXIgZ2V0SG90R2VuZXJhdGlvbiA9IGZ1bmN0aW9uIGdldEhvdEdlbmVyYXRpb24oKSB7XG4gIHJldHVybiBob3RSZXBsYWNlbWVudEdlbmVyYXRpb247XG59O1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKCdsb2Rhc2gvbWVyZ2UnKTtcblxudmFyIHNpZ25hdHVyZXMgPSB2b2lkIDA7XG52YXIgcHJveGllc0J5SUQgPSB2b2lkIDA7XG52YXIgYmxhY2tMaXN0ZWRQcm94aWVzID0gdm9pZCAwO1xudmFyIHJlZ2lzdGVyZWRDb21wb25lbnRzID0gdm9pZCAwO1xudmFyIGlkc0J5VHlwZSA9IHZvaWQgMDtcblxudmFyIGVsZW1lbnRDb3VudCA9IDA7XG52YXIgcmVuZGVyT3B0aW9ucyA9IHt9O1xuXG52YXIgY29tcG9uZW50T3B0aW9ucyA9IHZvaWQgMDtcblxudmFyIGdlbmVyYXRlVHlwZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVUeXBlSWQoKSB7XG4gIHJldHVybiAnYXV0by0nICsgZWxlbWVudENvdW50Kys7XG59O1xuXG52YXIgZ2V0SWRCeVR5cGUgPSBmdW5jdGlvbiBnZXRJZEJ5VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpZHNCeVR5cGUuZ2V0KHR5cGUpO1xufTtcbnZhciBpc1Byb3h5VHlwZSA9IGZ1bmN0aW9uIGlzUHJveHlUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVbUFJPWFlfS0VZXTtcbn07XG5cbnZhciBnZXRQcm94eUJ5SWQgPSBmdW5jdGlvbiBnZXRQcm94eUJ5SWQoaWQpIHtcbiAgcmV0dXJuIHByb3hpZXNCeUlEW2lkXTtcbn07XG52YXIgZ2V0UHJveHlCeVR5cGUgPSBmdW5jdGlvbiBnZXRQcm94eUJ5VHlwZSh0eXBlKSB7XG4gIHJldHVybiBnZXRQcm94eUJ5SWQoZ2V0SWRCeVR5cGUodHlwZSkpO1xufTtcblxudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnQodHlwZSkge1xuICByZXR1cm4gcmVnaXN0ZXJlZENvbXBvbmVudHMuc2V0KHR5cGUsIDEpO1xufTtcbnZhciBpc1JlZ2lzdGVyZWRDb21wb25lbnQgPSBmdW5jdGlvbiBpc1JlZ2lzdGVyZWRDb21wb25lbnQodHlwZSkge1xuICByZXR1cm4gcmVnaXN0ZXJlZENvbXBvbmVudHMuaGFzKHR5cGUpO1xufTtcblxudmFyIHNldFN0YW5kSW5PcHRpb25zID0gZnVuY3Rpb24gc2V0U3RhbmRJbk9wdGlvbnMob3B0aW9ucykge1xuICByZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbnZhciB1cGRhdGVGdW5jdGlvblByb3h5QnlJZCA9IGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uUHJveHlCeUlkKGlkLCB0eXBlLCB1cGRhdGVyKSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBJRC5cbiAgaWRzQnlUeXBlLnNldCh0eXBlLCBpZCk7XG4gIHZhciBwcm94eSA9IHByb3hpZXNCeUlEW2lkXTtcbiAgaWYgKCFwcm94eSkge1xuICAgIGlkc0J5VHlwZS5zZXQodHlwZSwgaWQpO1xuICAgIHByb3hpZXNCeUlEW2lkXSA9IHR5cGU7XG4gIH1cbiAgdXBkYXRlcihwcm94aWVzQnlJRFtpZF0sIHR5cGUpO1xuXG4gIHJldHVybiBwcm94aWVzQnlJRFtpZF07XG59O1xuXG52YXIgdXBkYXRlUHJveHlCeUlkID0gZnVuY3Rpb24gdXBkYXRlUHJveHlCeUlkKGlkLCB0eXBlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gUmVtZW1iZXIgdGhlIElELlxuICBpZHNCeVR5cGUuc2V0KHR5cGUsIGlkKTtcblxuICBpZiAoIXByb3hpZXNCeUlEW2lkXSkge1xuICAgIHByb3hpZXNCeUlEW2lkXSA9IGNyZWF0ZUNsYXNzUHJveHkodHlwZSwgaWQsIG1lcmdlKHt9LCByZW5kZXJPcHRpb25zLCB7IHByb3h5OiBjb21wb25lbnRPcHRpb25zLmdldCh0eXBlKSB8fCB7fSB9LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgcHJveGllc0J5SURbaWRdLnVwZGF0ZSh0eXBlKTtcbiAgICAvLyBwcm94eSBjb3VsZCBiZSByZWdpc3RlcmVkIGFnYWluIG9ubHkgaW4gY2FzZSBvZiBITVJcbiAgICBpbmNyZW1lbnRIb3RHZW5lcmF0aW9uKCk7XG4gIH1cbiAgcmV0dXJuIHByb3hpZXNCeUlEW2lkXTtcbn07XG5cbnZhciBjcmVhdGVQcm94eUZvclR5cGUgPSBmdW5jdGlvbiBjcmVhdGVQcm94eUZvclR5cGUodHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gZ2V0UHJveHlCeVR5cGUodHlwZSkgfHwgdXBkYXRlUHJveHlCeUlkKGdlbmVyYXRlVHlwZUlkKCksIHR5cGUsIG9wdGlvbnMpO1xufTtcblxudmFyIGlzQ29sZFR5cGUgPSBmdW5jdGlvbiBpc0NvbGRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGJsYWNrTGlzdGVkUHJveGllcy5oYXModHlwZSk7XG59O1xuXG52YXIgaXNUeXBlQmxhY2tsaXN0ZWQgPSBmdW5jdGlvbiBpc1R5cGVCbGFja2xpc3RlZCh0eXBlKSB7XG4gIHJldHVybiBpc0NvbGRUeXBlKHR5cGUpIHx8IGlzQ29tcG9zaXRlQ29tcG9uZW50KHR5cGUpICYmIChjb25maWd1cmF0aW9uLmlnbm9yZVNGQyAmJiAhaXNSZWFjdENsYXNzKHR5cGUpIHx8IGNvbmZpZ3VyYXRpb24uaWdub3JlQ29tcG9uZW50cyAmJiBpc1JlYWN0Q2xhc3ModHlwZSkpO1xufTtcbnZhciBibGFja2xpc3RCeVR5cGUgPSBmdW5jdGlvbiBibGFja2xpc3RCeVR5cGUodHlwZSkge1xuICByZXR1cm4gYmxhY2tMaXN0ZWRQcm94aWVzLnNldCh0eXBlLCB0cnVlKTtcbn07XG5cbnZhciBzZXRDb21wb25lbnRPcHRpb25zID0gZnVuY3Rpb24gc2V0Q29tcG9uZW50T3B0aW9ucyhjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXBvbmVudE9wdGlvbnMuc2V0KGNvbXBvbmVudCwgb3B0aW9ucyk7XG59O1xuXG52YXIgYWRkU2lnbmF0dXJlID0gZnVuY3Rpb24gYWRkU2lnbmF0dXJlKHR5cGUsIHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2lnbmF0dXJlcy5zZXQodHlwZSwgc2lnbmF0dXJlKTtcbn07XG52YXIgZ2V0U2lnbmF0dXJlID0gZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKHR5cGUpIHtcbiAgcmV0dXJuIHNpZ25hdHVyZXMuZ2V0KHR5cGUpO1xufTtcblxudmFyIHJlc2V0UHJveGllcyA9IGZ1bmN0aW9uIHJlc2V0UHJveGllcygpIHtcbiAgcHJveGllc0J5SUQgPSB7fTtcbiAgaWRzQnlUeXBlID0gbmV3IFdlYWtNYXAoKTtcbiAgYmxhY2tMaXN0ZWRQcm94aWVzID0gbmV3IFdlYWtNYXAoKTtcbiAgcmVnaXN0ZXJlZENvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuICBjb21wb25lbnRPcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgc2lnbmF0dXJlcyA9IG5ldyBXZWFrTWFwKCk7XG4gIHJlc2V0Q2xhc3NQcm94aWVzKCk7XG59O1xuXG5yZXNldFByb3hpZXMoKTtcblxudmFyIHR1bmUgPSB7XG4gIGFsbG93U0ZDOiBmYWxzZVxufTtcblxudmFyIHByZWFjdEFkYXB0ZXIgPSBmdW5jdGlvbiBwcmVhY3RBZGFwdGVyKGluc3RhbmNlLCByZXNvbHZlVHlwZSkge1xuICB2YXIgb2xkSGFuZGxlciA9IGluc3RhbmNlLm9wdGlvbnMudm5vZGU7XG5cbiAgc2V0Q29uZmlndXJhdGlvbih0dW5lKTtcblxuICBpbnN0YW5jZS5vcHRpb25zLnZub2RlID0gZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgdm5vZGUubm9kZU5hbWUgPSByZXNvbHZlVHlwZSh2bm9kZS5ub2RlTmFtZSk7XG4gICAgaWYgKG9sZEhhbmRsZXIpIHtcbiAgICAgIG9sZEhhbmRsZXIodm5vZGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qIGdsb2JhbCBkb2N1bWVudCAqL1xuXG52YXIgbGFzdEVycm9yID0gW107XG5cbnZhciBvdmVybGF5U3R5bGUgPSB7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICBsZWZ0OiAwLFxuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuXG4gIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LDIwMCwyMDAsMC45KScsXG5cbiAgY29sb3I6ICcjMDAwJyxcbiAgZm9udEZhbWlseTogJy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBcIlJvYm90b1wiLCBcIk94eWdlblwiLCBcIlVidW50dVwiLCBcIkZpcmEgU2Fuc1wiLCBcIkRyb2lkIFNhbnNcIiwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBzYW5zLXNlcmlmJyxcbiAgZm9udFNpemU6ICcxMnB4JyxcbiAgbWFyZ2luOiAwLFxuICBwYWRkaW5nOiAnMTZweCcsXG4gIG1heEhlaWdodDogJzUwJScsXG4gIG92ZXJmbG93OiAnYXV0bydcbn07XG5cbnZhciBpbmxpbmVFcnJvclN0eWxlID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICcjRkVFJ1xufTtcblxudmFyIGxpQ291bnRlciA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIGxlZnQ6ICcxMHB4J1xufTtcblxudmFyIGxpc3RTdHlsZSA9IHt9O1xuXG52YXIgRW1wdHlFcnJvclBsYWNlaG9sZGVyID0gZnVuY3Rpb24gRW1wdHlFcnJvclBsYWNlaG9sZGVyKF9yZWYpIHtcbiAgdmFyIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50O1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAnc3BhbicsXG4gICAgeyBzdHlsZTogaW5saW5lRXJyb3JTdHlsZSwgcm9sZTogJ2ltZycsICdhcmlhLWxhYmVsJzogJ1JlY3QtSG90LUxvYWRlciBFcnJvcicgfSxcbiAgICAnXFx1MjY5QlxcdUZFMEZcXHVEODNEXFx1REQyNVxcdUQ4M0VcXHVERDE1ICgnLFxuICAgIGNvbXBvbmVudCA/IGdldENvbXBvbmVudERpc3BsYXlOYW1lKGNvbXBvbmVudC5jb25zdHJ1Y3RvciB8fCBjb21wb25lbnQpIDogJ1Vua25vd24gbG9jYXRpb24nLFxuICAgICcpJyxcbiAgICBjb21wb25lbnQgJiYgY29tcG9uZW50LnJldHJ5SG90TG9hZGVyRXJyb3IgJiYgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdidXR0b24nLFxuICAgICAgeyBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnQucmV0cnlIb3RMb2FkZXJFcnJvcigpO1xuICAgICAgICB9LCB0aXRsZTogJ1JldHJ5JyB9LFxuICAgICAgJ1xcdTI3RjMnXG4gICAgKVxuICApO1xufTtcblxudmFyIGVycm9ySGVhZGVyID0gZnVuY3Rpb24gZXJyb3JIZWFkZXIoY29tcG9uZW50LCBjb21wb25lbnRTdGFjaykge1xuICBpZiAoY29tcG9uZW50IHx8IGNvbXBvbmVudFN0YWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICBudWxsLFxuICAgICAgJygnLFxuICAgICAgY29tcG9uZW50ID8gZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUoY29tcG9uZW50LmNvbnN0cnVjdG9yIHx8IGNvbXBvbmVudCkgOiAnVW5rbm93biBsb2NhdGlvbicsXG4gICAgICBjb21wb25lbnQgJiYgJywgJyxcbiAgICAgIGNvbXBvbmVudFN0YWNrICYmIGNvbXBvbmVudFN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbilbMF0sXG4gICAgICAnKSdcbiAgICApO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIG1hcEVycm9yID0gZnVuY3Rpb24gbWFwRXJyb3IoX3JlZjIpIHtcbiAgdmFyIGVycm9yID0gX3JlZjIuZXJyb3IsXG4gICAgICBlcnJvckluZm8gPSBfcmVmMi5lcnJvckluZm8sXG4gICAgICBjb21wb25lbnQgPSBfcmVmMi5jb21wb25lbnQ7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgIFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LFxuICAgIG51bGwsXG4gICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdwJyxcbiAgICAgIHsgc3R5bGU6IHsgY29sb3I6ICdyZWQnIH0gfSxcbiAgICAgIGVycm9ySGVhZGVyKGNvbXBvbmVudCwgZXJyb3JJbmZvICYmIGVycm9ySW5mby5jb21wb25lbnRTdGFjayksXG4gICAgICAnICcsXG4gICAgICBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiBlcnJvci5tZXNzYWdlIHx8ICd1bmRlZmluZWQgZXJyb3InXG4gICAgKSxcbiAgICBlcnJvckluZm8gJiYgZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgbnVsbCxcbiAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICAnU3RhY2sgdHJhY2U6J1xuICAgICAgKSxcbiAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd1bCcsXG4gICAgICAgIHsgc3R5bGU6IHsgY29sb3I6ICdyZWQnLCBtYXJnaW5Ub3A6ICcxMHB4JyB9IH0sXG4gICAgICAgIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxLCAyKS5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICB7IGtleTogU3RyaW5nKGkpIH0sXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2hyJywgbnVsbCksXG4gICAgICAgIGVycm9ySW5mby5jb21wb25lbnRTdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIHsga2V5OiBTdHJpbmcoaSkgfSxcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICkgOiBlcnJvci5zdGFjayAmJiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICBudWxsLFxuICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdTdGFjayB0cmFjZTonXG4gICAgICApLFxuICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3VsJyxcbiAgICAgICAgeyBzdHlsZTogeyBjb2xvcjogJ3JlZCcsIG1hcmdpblRvcDogJzEwcHgnIH0gfSxcbiAgICAgICAgZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIHsga2V5OiBTdHJpbmcoaSkgfSxcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcbiAgKTtcbn07XG5cbnZhciBFcnJvck92ZXJsYXkgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBpbmhlcml0cyhFcnJvck92ZXJsYXksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEVycm9yT3ZlcmxheSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JPdmVybGF5KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0sIF90aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7IHZpc2libGU6ICFfdGhpcy5zdGF0ZS52aXNpYmxlIH0pO1xuICAgIH0sIF90aGlzLnJldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IF90aGlzLnByb3BzLmVycm9ycztcblxuICAgICAgICBlbnRlckhvdFVwZGF0ZSgpO1xuICAgICAgICBjbGVhckV4Y2VwdGlvbnMoKTtcbiAgICAgICAgZXJyb3JzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3JlZjMuY29tcG9uZW50O1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgdmFyIHJldHJ5SG90TG9hZGVyRXJyb3IgPSBfcmVmNC5yZXRyeUhvdExvYWRlckVycm9yO1xuICAgICAgICAgIHJldHVybiAhIXJldHJ5SG90TG9hZGVyRXJyb3I7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnQucmV0cnlIb3RMb2FkZXJFcnJvcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcbiAgICB9LCBfdGVtcCksIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgRXJyb3JPdmVybGF5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGVycm9ycyA9IHRoaXMucHJvcHMuZXJyb3JzO1xuXG4gICAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHZpc2libGUgPSB0aGlzLnN0YXRlLnZpc2libGU7XG5cbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBzdHlsZTogb3ZlcmxheVN0eWxlIH0sXG4gICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnaDInLFxuICAgICAgICB7IHN0eWxlOiB7IG1hcmdpbjogMCB9IH0sXG4gICAgICAgICdcXHUyNjlCXFx1RkUwRlxcdUQ4M0RcXHVERDI1XFx1RDgzRFxcdURFMkQ6IGhvdCB1cGRhdGUgd2FzIG5vdCBzdWNjZXNzZnVsICcsXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgeyBvbkNsaWNrOiB0aGlzLnRvZ2dsZSB9LFxuICAgICAgICAgIHZpc2libGUgPyAnY29sbGFwc2UnIDogJ2V4cGFuZCdcbiAgICAgICAgKSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICB7IG9uQ2xpY2s6IHRoaXMucmV0cnkgfSxcbiAgICAgICAgICAnUmV0cnknXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICB2aXNpYmxlICYmIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICd1bCcsXG4gICAgICAgIHsgc3R5bGU6IGxpc3RTdHlsZSB9LFxuICAgICAgICBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICB7IGtleTogaSB9LFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgICAgICB7IHN0eWxlOiBsaUNvdW50ZXIgfSxcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICBpICsgMSxcbiAgICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgICBlcnJvcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtYXBFcnJvcihlcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBFcnJvck92ZXJsYXk7XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCk7XG5cbnZhciBpbml0RXJyb3JPdmVybGF5ID0gZnVuY3Rpb24gaW5pdEVycm9yT3ZlcmxheSgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1ob3QtbG9hZGVyLWVycm9yLW92ZXJsYXknKTtcbiAgaWYgKCFkaXYpIHtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gJ3JlYWN0LWhvdC1sb2FkZXItZXJyb3Itb3ZlcmxheSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICB9XG4gIGlmIChsYXN0RXJyb3IubGVuZ3RoKSB7XG4gICAgdmFyIE92ZXJsYXkgPSBjb25maWd1cmF0aW9uLkVycm9yT3ZlcmxheSB8fCBFcnJvck92ZXJsYXk7XG4gICAgUmVhY3RET00ucmVuZGVyKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheSwgeyBlcnJvcnM6IGxhc3RFcnJvciB9KSwgZGl2KTtcbiAgfSBlbHNlIHtcbiAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGVhckV4Y2VwdGlvbnMoKSB7XG4gIGlmIChsYXN0RXJyb3IubGVuZ3RoKSB7XG4gICAgbGFzdEVycm9yID0gW107XG4gICAgaW5pdEVycm9yT3ZlcmxheSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihlcnJvciwgZXJyb3JJbmZvLCBjb21wb25lbnQpIHtcbiAgLy8gZG8gbm90IHN1cHByZXNzIGVycm9yXG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIGxhc3RFcnJvci5wdXNoKHsgZXJyb3I6IGVycm9yLCBlcnJvckluZm86IGVycm9ySW5mbywgY29tcG9uZW50OiBjb21wb25lbnQgfSk7XG4gIGluaXRFcnJvck92ZXJsYXkoKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGhvdFJlbmRlcldpdGhIb29rcyA9IFJlYWN0RE9NLmhvdFJlbmRlcldpdGhIb29rcyB8fCBmdW5jdGlvbiAoZmliZXIsIHJlbmRlcikge1xuICByZXR1cm4gcmVuZGVyKCk7XG59O1xuXG5mdW5jdGlvbiBwdXNoU3RhY2soc3RhY2ssIG5vZGUpIHtcbiAgc3RhY2sudHlwZSA9IG5vZGUudHlwZTtcbiAgc3RhY2suZWxlbWVudFR5cGUgPSBub2RlLmVsZW1lbnRUeXBlIHx8IG5vZGUudHlwZTtcbiAgc3RhY2suY2hpbGRyZW4gPSBbXTtcbiAgc3RhY2suaW5zdGFuY2UgPSB0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nID8gbm9kZS5zdGF0ZU5vZGUgOiBzdGFjaztcbiAgc3RhY2suZmliZXIgPSBub2RlO1xuXG4gIGlmICghc3RhY2suaW5zdGFuY2UpIHtcbiAgICBzdGFjay5pbnN0YW5jZSA9IHtcbiAgICAgIFNGQ19mYWtlOiBzdGFjay50eXBlLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBob3RSZW5kZXJXaXRoSG9va3Mobm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdGFjay50eXBlKHN0YWNrLmluc3RhbmNlLnByb3BzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoeWRyYXRlRmliZXJTdGFjayhub2RlLCBzdGFjaykge1xuICBwdXNoU3RhY2soc3RhY2ssIG5vZGUpO1xuICBpZiAobm9kZS5jaGlsZCkge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgY2hpbGRTdGFjayA9IHt9O1xuICAgICAgaHlkcmF0ZUZpYmVyU3RhY2soY2hpbGQsIGNoaWxkU3RhY2spO1xuICAgICAgc3RhY2suY2hpbGRyZW4ucHVzaChjaGlsZFN0YWNrKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9IHdoaWxlIChjaGlsZCk7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxuZnVuY3Rpb24gcHVzaFN0YXRlKHN0YWNrLCB0eXBlLCBpbnN0YW5jZSkge1xuICBzdGFjay50eXBlID0gdHlwZTtcbiAgc3RhY2suZWxlbWVudFR5cGUgPSB0eXBlO1xuICBzdGFjay5jaGlsZHJlbiA9IFtdO1xuICBzdGFjay5pbnN0YW5jZSA9IGluc3RhbmNlIHx8IHN0YWNrO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmlzU3RhdGVsZXNzRnVuY3Rpb25hbFByb3h5KSB7XG4gICAgLy8gSW4gUmVhY3QgMTUgU0ZDIGlzIHdyYXBwZWQgYnkgY29tcG9uZW50LiBXZSBoYXZlIHRvIGRldGVjdCBvdXIgcHJveGllcyBhbmQgY2hhbmdlIHRoZSB3YXkgaXQgd29ya3NcbiAgICBzdGFjay5pbnN0YW5jZSA9IHtcbiAgICAgIFNGQ19mYWtlOiB0eXBlLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0eXBlKHN0YWNrLmluc3RhbmNlLnByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVMZWdhY3lTdGFjayhub2RlLCBzdGFjaykge1xuICBpZiAobm9kZS5fY3VycmVudEVsZW1lbnQpIHtcbiAgICBwdXNoU3RhdGUoc3RhY2ssIG5vZGUuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG5vZGUuX2luc3RhbmNlIHx8IHN0YWNrKTtcbiAgfVxuXG4gIGlmIChub2RlLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIHZhciBjaGlsZFN0YWNrID0ge307XG4gICAgaHlkcmF0ZUxlZ2FjeVN0YWNrKG5vZGUuX3JlbmRlcmVkQ29tcG9uZW50LCBjaGlsZFN0YWNrKTtcbiAgICBzdGFjay5jaGlsZHJlbi5wdXNoKGNoaWxkU3RhY2spO1xuICB9IGVsc2UgaWYgKG5vZGUuX3JlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICBPYmplY3Qua2V5cyhub2RlLl9yZW5kZXJlZENoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBjaGlsZFN0YWNrID0ge307XG4gICAgICBoeWRyYXRlTGVnYWN5U3RhY2sobm9kZS5fcmVuZGVyZWRDaGlsZHJlbltrZXldLCBjaGlsZFN0YWNrKTtcbiAgICAgIHN0YWNrLmNoaWxkcmVuLnB1c2goY2hpbGRTdGFjayk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxuZnVuY3Rpb24gZ2V0UmVhY3RTdGFjayhpbnN0YW5jZSkge1xuICB2YXIgcm9vdE5vZGUgPSBnZXRJbnRlcm5hbEluc3RhbmNlKGluc3RhbmNlKTtcbiAgdmFyIHN0YWNrID0ge307XG4gIGlmIChyb290Tm9kZSkge1xuICAgIC8vIFJlYWN0IHN0YWNrXG4gICAgdmFyIGlzRmliZXIgPSB0eXBlb2Ygcm9vdE5vZGUudGFnID09PSAnbnVtYmVyJztcbiAgICBpZiAoaXNGaWJlcikge1xuICAgICAgaHlkcmF0ZUZpYmVyU3RhY2socm9vdE5vZGUsIHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaHlkcmF0ZUxlZ2FjeVN0YWNrKHJvb3ROb2RlLCBzdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG52YXIgbWFya1VwZGF0ZSA9IGZ1bmN0aW9uIG1hcmtVcGRhdGUoX3JlZikge1xuICB2YXIgZmliZXIgPSBfcmVmLmZpYmVyO1xuXG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSAxO1xuICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gMTtcbiAgICBmaWJlci5hbHRlcm5hdGUudHlwZSA9IGZpYmVyLnR5cGU7XG4gIH1cblxuICBpZiAoZmliZXIubWVtb2l6ZWRQcm9wcyAmJiBfdHlwZW9mKGZpYmVyLm1lbW9pemVkUHJvcHMpID09PSAnb2JqZWN0Jykge1xuICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICBjYWNoZUJ1c3RlclByb3A6IHRydWVcbiAgICB9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgfVxuXG4gIGlmIChmaWJlci5zdGF0ZU5vZGUpIDtcbn07XG5cbnZhciBjbGVhbnVwUmVhY3QgPSBmdW5jdGlvbiBjbGVhbnVwUmVhY3QoKSB7XG4gIGlmIChSZWFjdERPTS5ob3RDbGVhbnVwKSB7XG4gICAgUmVhY3RET00uaG90Q2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgZGVlcE1hcmtVcGRhdGUgPSBmdW5jdGlvbiBkZWVwTWFya1VwZGF0ZShzdGFjaykge1xuICBtYXJrVXBkYXRlKHN0YWNrKTtcbiAgaWYgKHN0YWNrLmNoaWxkcmVuKSB7XG4gICAgc3RhY2suY2hpbGRyZW4uZm9yRWFjaChkZWVwTWFya1VwZGF0ZSk7XG4gIH1cbn07XG5cbi8vIHNvbWUgYGVtcHR5YCBuYW1lcywgUmVhY3QgY2FuIGF1dG9zZXQgZGlzcGxheSBuYW1lIHRvLi4uXG52YXIgVU5ERUZJTkVEX05BTUVTID0ge1xuICBVbmtub3duOiB0cnVlLFxuICBDb21wb25lbnQ6IHRydWVcbn07XG5cbnZhciBhcmVOYW1lc0VxdWFsID0gZnVuY3Rpb24gYXJlTmFtZXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IFVOREVGSU5FRF9OQU1FU1thXSAmJiBVTkRFRklORURfTkFNRVNbYl07XG59O1xuXG52YXIgaXNGdW5jdGlvbmFsID0gZnVuY3Rpb24gaXNGdW5jdGlvbmFsKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XG59O1xudmFyIGdldFR5cGVPZiA9IGZ1bmN0aW9uIGdldFR5cGVPZih0eXBlKSB7XG4gIGlmIChpc1JlYWN0Q2xhc3ModHlwZSkpIHJldHVybiAnUmVhY3RDb21wb25lbnQnO1xuICBpZiAoaXNGdW5jdGlvbmFsKHR5cGUpKSByZXR1cm4gJ1N0YXRlbGVzc0Z1bmN0aW9uYWwnO1xuICByZXR1cm4gJ0ZyYWdtZW50JzsgLy8gP1xufTtcblxudmFyIGhhdmVUZXh0U2ltaWxhcml0eSA9IGZ1bmN0aW9uIGhhdmVUZXh0U2ltaWxhcml0eShhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgLy8gZXF1YWwgb3Igc2xpZ2h0IGNoYW5nZWRcbiAgICBhID09PSBiIHx8IGxldmVuc2h0ZWluLmdldChhLCBiKSA8IGEubGVuZ3RoICogMC4yXG4gICk7XG59O1xuXG52YXIgZ2V0QmFzZVByb3RvID0gZnVuY3Rpb24gZ2V0QmFzZVByb3RvKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlLnByb3RvdHlwZS5ob3RDb21wb25lbnRSZW5kZXIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlLnByb3RvdHlwZSkgOiBzb3VyY2UucHJvdG90eXBlO1xufTtcblxudmFyIGVxdWFsQ2xhc3NlcyA9IGZ1bmN0aW9uIGVxdWFsQ2xhc3NlcyhhLCBiKSB7XG4gIHZhciBwcm90b3R5cGVBID0gZ2V0QmFzZVByb3RvKGEpO1xuICB2YXIgcHJvdG90eXBlQiA9IGdldEJhc2VQcm90byhiKTtcblxuICB2YXIgaGl0cyA9IDA7XG4gIHZhciBtaXNzZXMgPSAwO1xuICB2YXIgY29tcGFyaXNvbnMgPSAwO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGVBKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZGVzY3JpcHRvckEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZUEsIGtleSk7XG4gICAgdmFyIHZhbHVlQSA9IGRlc2NyaXB0b3JBICYmIChkZXNjcmlwdG9yQS52YWx1ZSB8fCBkZXNjcmlwdG9yQS5nZXQgfHwgZGVzY3JpcHRvckEuc2V0KTtcbiAgICB2YXIgZGVzY3JpcHRvckIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZUIsIGtleSk7XG4gICAgdmFyIHZhbHVlQiA9IGRlc2NyaXB0b3JCICYmIChkZXNjcmlwdG9yQi52YWx1ZSB8fCBkZXNjcmlwdG9yQi5nZXQgfHwgZGVzY3JpcHRvckIuc2V0KTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWVBID09PSAnZnVuY3Rpb24nICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgY29tcGFyaXNvbnMrKztcbiAgICAgIGlmIChoYXZlVGV4dFNpbWlsYXJpdHkoU3RyaW5nKHZhbHVlQSksIFN0cmluZyh2YWx1ZUIpKSkge1xuICAgICAgICBoaXRzKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXNzZXMrKztcbiAgICAgICAgaWYgKGtleSA9PT0gJ3JlbmRlcicpIHtcbiAgICAgICAgICBtaXNzZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIGFsbG93IHRvIGFkZCBvciByZW1vdmUgb25lIGZ1bmN0aW9uXG4gIHJldHVybiBoaXRzID4gMCAmJiBtaXNzZXMgPD0gMSB8fCBjb21wYXJpc29ucyA9PT0gMDtcbn07XG5cbnZhciBhcmVTd2FwcGFibGUgPSBmdW5jdGlvbiBhcmVTd2FwcGFibGUoYSwgYikge1xuICAvLyBib3RoIGFyZSByZWdpc3RlcmVkIGNvbXBvbmVudHMgYW5kIGhhdmUgdGhlIHNhbWUgbmFtZVxuICBpZiAoZ2V0SWRCeVR5cGUoYikgJiYgZ2V0SWRCeVR5cGUoYSkgPT09IGdldElkQnlUeXBlKGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGdldFR5cGVPZihhKSAhPT0gZ2V0VHlwZU9mKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1JlYWN0Q2xhc3MoYSkpIHtcbiAgICByZXR1cm4gYXJlTmFtZXNFcXVhbChnZXRDb21wb25lbnREaXNwbGF5TmFtZShhKSwgZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUoYikpICYmIGVxdWFsQ2xhc3NlcyhhLCBiKTtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uYWwoYSkpIHtcbiAgICB2YXIgbmFtZUEgPSBnZXRDb21wb25lbnREaXNwbGF5TmFtZShhKTtcbiAgICBpZiAoIWFyZU5hbWVzRXF1YWwobmFtZUEsIGdldENvbXBvbmVudERpc3BsYXlOYW1lKGIpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZUEgIT09ICdDb21wb25lbnQnIHx8IGhhdmVUZXh0U2ltaWxhcml0eShTdHJpbmcoYSksIFN0cmluZyhiKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHNob3VsZE5vdFBhdGNoQ29tcG9uZW50ID0gZnVuY3Rpb24gc2hvdWxkTm90UGF0Y2hDb21wb25lbnQodHlwZSkge1xuICByZXR1cm4gaXNUeXBlQmxhY2tsaXN0ZWQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlVHlwZSh0eXBlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAoaXNMYXp5VHlwZSh7IHR5cGU6IHR5cGUgfSkgfHwgaXNNZW1vVHlwZSh7IHR5cGU6IHR5cGUgfSkgfHwgaXNGb3J3YXJkVHlwZSh7IHR5cGU6IHR5cGUgfSkpIHtcbiAgICByZXR1cm4gZ2V0UHJveHlCeVR5cGUodHlwZSkgfHwgdHlwZTtcbiAgfVxuXG4gIGlmICghaXNDb21wb3NpdGVDb21wb25lbnQodHlwZSkgfHwgaXNQcm94eVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHZhciBleGlzdGluZ1Byb3h5ID0gZ2V0UHJveHlCeVR5cGUodHlwZSk7XG5cbiAgaWYgKHNob3VsZE5vdFBhdGNoQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHkgPyBleGlzdGluZ1Byb3h5LmdldEN1cnJlbnQoKSA6IHR5cGU7XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nUHJveHkgJiYgY29uZmlndXJhdGlvbi5vbkNvbXBvbmVudENyZWF0ZSkge1xuICAgIGNvbmZpZ3VyYXRpb24ub25Db21wb25lbnRDcmVhdGUodHlwZSwgZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUodHlwZSkpO1xuICAgIGlmIChzaG91bGROb3RQYXRjaENvbXBvbmVudCh0eXBlKSkgcmV0dXJuIHR5cGU7XG4gIH1cblxuICB2YXIgcHJveHkgPSBpbnRlcm5hbENvbmZpZ3VyYXRpb24uZGlzYWJsZVByb3h5Q3JlYXRpb24gPyBleGlzdGluZ1Byb3h5IDogY3JlYXRlUHJveHlGb3JUeXBlKHR5cGUsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBwcm94eSA/IHByb3h5LmdldCgpIDogdHlwZTtcbn1cblxudmFyIHJlbmRlclN0YWNrID0gW107XG5cbnZhciBzdGFja1JlcG9ydCA9IGZ1bmN0aW9uIHN0YWNrUmVwb3J0KCkge1xuICB2YXIgcmV2ID0gcmVuZGVyU3RhY2suc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGxvZ2dlci53YXJuKCdpbicsIHJldlswXS5uYW1lLCByZXYpO1xufTtcblxudmFyIGVtcHR5TWFwID0gbmV3IE1hcCgpO1xudmFyIHN0YWNrQ29udGV4dCA9IGZ1bmN0aW9uIHN0YWNrQ29udGV4dCgpIHtcbiAgcmV0dXJuIChyZW5kZXJTdGFja1tyZW5kZXJTdGFjay5sZW5ndGggLSAxXSB8fCB7fSkuY29udGV4dCB8fCBlbXB0eU1hcDtcbn07XG5cbnZhciBzaG91bGRVc2VSZW5kZXJNZXRob2QgPSBmdW5jdGlvbiBzaG91bGRVc2VSZW5kZXJNZXRob2QoZm4pIHtcbiAgcmV0dXJuIGZuICYmIChpc1JlYWN0Q2xhc3NJbnN0YW5jZShmbikgfHwgZm4uU0ZDX2Zha2UpO1xufTtcblxudmFyIGdldEVsZW1lbnRUeXBlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFR5cGUoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLnR5cGVbVU5XUkFQX1BST1hZXSA/IGNoaWxkLnR5cGVbVU5XUkFQX1BST1hZXSgpIDogY2hpbGQudHlwZTtcbn07XG5cbnZhciBmaWx0ZXJOdWxsQXJyYXkgPSBmdW5jdGlvbiBmaWx0ZXJOdWxsQXJyYXkoYSkge1xuICBpZiAoIWEpIHJldHVybiBbXTtcbiAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuICEheDtcbiAgfSk7XG59O1xuXG52YXIgdW5mbGF0dGVuID0gZnVuY3Rpb24gdW5mbGF0dGVuKGEpIHtcbiAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgYWNjLnB1c2guYXBwbHkoYWNjLCB1bmZsYXR0ZW4oYSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufTtcblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGZuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGZuKTtcbn07XG52YXIgYXNBcnJheSA9IGZ1bmN0aW9uIGFzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheShhKSA/IGEgOiBbYV07XG59O1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvbXBvbmVudCwgc3RhY2spIHtcbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGNvbXBvbmVudC5ob3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICBjb21wb25lbnQuaG90Q29tcG9uZW50VXBkYXRlKCk7XG4gIH1cbiAgaWYgKHNob3VsZFVzZVJlbmRlck1ldGhvZChjb21wb25lbnQpKSB7XG4gICAgLy8gbm90IGNhbGxpbmcgcmVhbCByZW5kZXIgbWV0aG9kIHRvIHByZXZlbnQgY2FsbCByZWN1cnNpb24uXG4gICAgLy8gc3RhdGVsZXNzIGNvbXBvbmVudHMgZG9lcyBub3QgaGF2ZSBob3RDb21wb25lbnRSZW5kZXJcbiAgICByZXR1cm4gY29tcG9uZW50LmhvdENvbXBvbmVudFJlbmRlciA/IGNvbXBvbmVudC5ob3RDb21wb25lbnRSZW5kZXIoKSA6IGNvbXBvbmVudC5yZW5kZXIoKTtcbiAgfVxuICBpZiAoaXNGb3J3YXJkVHlwZShjb21wb25lbnQpKSB7XG4gICAgLy8gcmVuZGVyIGZvcndhcmQgdHlwZSBpbiBhIHNhbmRib3hcbiAgICByZXR1cm4gaG90UmVuZGVyV2l0aEhvb2tzKHN0YWNrLmZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LnR5cGUucmVuZGVyKGNvbXBvbmVudC5wcm9wcywgbnVsbCk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzQXJyYXkoY29tcG9uZW50KSkge1xuICAgIHJldHVybiBjb21wb25lbnQubWFwKHJlbmRlcik7XG4gIH1cbiAgaWYgKGNvbXBvbmVudC5jaGlsZHJlbikge1xuICAgIHJldHVybiBjb21wb25lbnQuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gW107XG59O1xuXG52YXIgTk9fQ0hJTERSRU4gPSB7IGNoaWxkcmVuOiBbXSB9O1xudmFyIG1hcENoaWxkcmVuID0gZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGluc3RhbmNlcykge1xuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICBpZiAoKHR5cGVvZiBjaGlsZCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2hpbGQpKSAhPT0gJ29iamVjdCcgfHwgY2hpbGQuaXNNZXJnZWQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgICAgdmFyIGluc3RhbmNlTGluZSA9IGluc3RhbmNlc1tpbmRleF0gfHwge307XG4gICAgICB2YXIgb2xkQ2hpbGRyZW4gPSBhc0FycmF5KGluc3RhbmNlTGluZS5jaGlsZHJlbiB8fCBbXSk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAgIHR5cGU6IG51bGxcbiAgICAgICAgfSwgbWFwQ2hpbGRyZW4oY2hpbGQsIG9sZENoaWxkcmVuKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGFzQXJyYXkoY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW4gfHwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGNoaWxkLnR5cGUgIT09ICdmdW5jdGlvbicgJiYgb2xkQ2hpbGRyZW4ubGVuZ3RoICYmIG1hcENoaWxkcmVuKG5ld0NoaWxkcmVuLCBvbGRDaGlsZHJlbik7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5leHRQcm9wczogY2hpbGQucHJvcHMsXG4gICAgICAgIGlzTWVyZ2VkOiB0cnVlXG4gICAgICB9LCBpbnN0YW5jZUxpbmUsIG5leHRDaGlsZHJlbiB8fCB7fSwge1xuICAgICAgICB0eXBlOiBjaGlsZC50eXBlXG4gICAgICB9KTtcbiAgICB9KVxuICB9O1xufTtcblxudmFyIG1lcmdlSW5qZWN0ID0gZnVuY3Rpb24gbWVyZ2VJbmplY3QoYSwgYiwgaW5zdGFuY2UpIHtcbiAgaWYgKGEgJiYgIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gbWVyZ2VJbmplY3QoW2FdLCBiKTtcbiAgfVxuICBpZiAoYiAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBtZXJnZUluamVjdChhLCBbYl0pO1xuICB9XG5cbiAgaWYgKCFhIHx8ICFiKSB7XG4gICAgcmV0dXJuIE5PX0NISUxEUkVOO1xuICB9XG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFwQ2hpbGRyZW4oYSwgYik7XG4gIH1cblxuICAvLyBpbiBzb21lIGNhc2VzIChubyBjb25maWRlbmNlIGhlcmUpIEIgY291bGQgY29udGFpbiBBIGV4Y2VwdCBudWxsIGNoaWxkcmVuXG4gIC8vIGluIHNvbWUgY2FzZXMgLSBjb3VsZCBub3QuXG4gIC8vIHRoaXMgZGVwZW5kcyBvbiBSZWFjdCB2ZXJzaW9uIGFuZCB0aGUgd2F5IHlvdSBidWlsZCBjb21wb25lbnQuXG5cbiAgdmFyIG5vbk51bGxBID0gZmlsdGVyTnVsbEFycmF5KGEpO1xuICBpZiAobm9uTnVsbEEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBtYXBDaGlsZHJlbihub25OdWxsQSwgYik7XG4gIH1cblxuICB2YXIgZmxhdEEgPSB1bmZsYXR0ZW4obm9uTnVsbEEpO1xuICB2YXIgZmxhdEIgPSB1bmZsYXR0ZW4oYik7XG4gIGlmIChmbGF0QS5sZW5ndGggPT09IGZsYXRCLmxlbmd0aCkge1xuICAgIHJldHVybiBtYXBDaGlsZHJlbihmbGF0QSwgZmxhdEIpO1xuICB9XG4gIGlmIChmbGF0Qi5sZW5ndGggPT09IDAgJiYgZmxhdEEubGVuZ3RoID09PSAxICYmIF90eXBlb2YoZmxhdEFbMF0pICE9PSAnb2JqZWN0JykgOyBlbHNlIGlmICghcmVhY3RIb3RMb2FkZXIuSVNfUkVBQ1RfTUVSR0VfRU5BQkxFRCkge1xuICAgIGxvZ2dlci53YXJuKCdSZWFjdC1ob3QtbG9hZGVyOiB1bmFibGUgdG8gbWVyZ2UgJywgYSwgJ2FuZCBjaGlsZHJlbiBvZiAnLCBpbnN0YW5jZSk7XG4gICAgc3RhY2tSZXBvcnQoKTtcbiAgfVxuICByZXR1cm4gTk9fQ0hJTERSRU47XG59O1xuXG52YXIgdHJhbnNmb3JtRmxvd05vZGUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1GbG93Tm9kZShmbG93KSB7XG4gIHJldHVybiBmbG93LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgaXNGcmFnbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChub2RlLnByb3BzICYmIG5vZGUucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChhY2MsIGZpbHRlck51bGxBcnJheShhc0FycmF5KG5vZGUucHJvcHMuY2hpbGRyZW4pKSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KGFjYywgZmlsdGVyTnVsbEFycmF5KGFzQXJyYXkobm9kZS5jaGlsZHJlbikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhY2MsIFtub2RlXSk7XG4gIH0sIFtdKTtcbn07XG5cbnZhciBzY2hlZHVsZWRVcGRhdGVzID0gW107XG52YXIgc2NoZWR1bGVkVXBkYXRlID0gMDtcblxudmFyIGZsdXNoU2NoZWR1bGVkVXBkYXRlcyA9IGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVkVXBkYXRlcygpIHtcbiAgdmFyIGluc3RhbmNlcyA9IHNjaGVkdWxlZFVwZGF0ZXM7XG4gIHNjaGVkdWxlZFVwZGF0ZXMgPSBbXTtcbiAgc2NoZWR1bGVkVXBkYXRlID0gMDtcbiAgaW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlW1BST1hZX0lTX01PVU5URURdICYmIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfSk7XG59O1xuXG52YXIgdW5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIHVuc2NoZWR1bGVVcGRhdGUoaW5zdGFuY2UpIHtcbiAgc2NoZWR1bGVkVXBkYXRlcyA9IHNjaGVkdWxlZFVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3QgIT09IGluc3RhbmNlO1xuICB9KTtcbn07XG5cbnZhciBzY2hlZHVsZUluc3RhbmNlVXBkYXRlID0gZnVuY3Rpb24gc2NoZWR1bGVJbnN0YW5jZVVwZGF0ZShpbnN0YW5jZSkge1xuICBzY2hlZHVsZWRVcGRhdGVzLnB1c2goaW5zdGFuY2UpO1xuICBpZiAoIXNjaGVkdWxlZFVwZGF0ZSkge1xuICAgIHNjaGVkdWxlZFVwZGF0ZSA9IHNldFRpbWVvdXQoZmx1c2hTY2hlZHVsZWRVcGRhdGVzLCA0KTtcbiAgfVxufTtcblxudmFyIGhvdFJlcGxhY2VtZW50UmVuZGVyID0gZnVuY3Rpb24gaG90UmVwbGFjZW1lbnRSZW5kZXIoaW5zdGFuY2UsIHN0YWNrKSB7XG4gIGlmIChpc1JlYWN0Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSkpIHtcbiAgICB2YXIgdHlwZSA9IGdldEVsZW1lbnRUeXBlKHN0YWNrKTtcblxuICAgIHJlbmRlclN0YWNrLnB1c2goe1xuICAgICAgbmFtZTogZ2V0Q29tcG9uZW50RGlzcGxheU5hbWUodHlwZSksXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcHJvcHM6IHN0YWNrLmluc3RhbmNlLnByb3BzLFxuICAgICAgY29udGV4dDogc3RhY2tDb250ZXh0KClcbiAgICB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGZsb3cgPSB0cmFuc2Zvcm1GbG93Tm9kZShmaWx0ZXJOdWxsQXJyYXkoYXNBcnJheShyZW5kZXIoaW5zdGFuY2UsIHN0YWNrKSkpKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHN0YWNrLmNoaWxkcmVuO1xuXG5cbiAgICBmbG93LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgdmFyIGNoaWxkVHlwZSA9IGNoaWxkLnR5cGU7XG4gICAgICB2YXIgc3RhY2tDaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dChpbnN0YW5jZSkge1xuICAgICAgICAvLyBjb3B5IG92ZXIgcHJvcHMgYXMgbG9uZyBuZXcgY29tcG9uZW50IG1heSBiZSBoaWRkZW4gaW5zaWRlIHRoZW1cbiAgICAgICAgLy8gY2hpbGQgZG9lcyBub3QgaGF2ZSBhbGwgcHJvcHMsIGFzIGxvbmcgc29tZSBvZiB0aGVtIGNhbiBiZSBjYWxjdWxhdGVkIG9uIGNvbXBvbmVudE1vdW50LlxuICAgICAgICB2YXIgcmVhbFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICAgIHZhciBuZXh0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVhbFByb3BzLCBjaGlsZC5uZXh0UHJvcHMgfHwge30sIGNoaWxkLnByb3BzIHx8IHt9KTtcblxuICAgICAgICBpZiAoaXNSZWFjdENsYXNzSW5zdGFuY2UoaW5zdGFuY2UpICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAvLyBGb3JjZS1yZWZyZXNoIGNvbXBvbmVudCAoYnlwYXNzIHJlZHV4IHJlbmRlcmVkQ29tcG9uZW50KVxuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUoX2V4dGVuZHMoe30sIHJlYWxQcm9wcyksIGluc3RhbmNlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgaG90UmVwbGFjZW1lbnRSZW5kZXIoaW5zdGFuY2UsIHN0YWNrQ2hpbGQpO1xuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHJlYWxQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIC8vIHRleHQgbm9kZVxuICAgICAgaWYgKCh0eXBlb2YgY2hpbGQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNoaWxkKSkgIT09ICdvYmplY3QnIHx8ICFzdGFja0NoaWxkIHx8ICFzdGFja0NoaWxkLmluc3RhbmNlKSB7XG4gICAgICAgIGlmIChzdGFja0NoaWxkICYmIHN0YWNrQ2hpbGQuY2hpbGRyZW4gJiYgc3RhY2tDaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlYWN0LWhvdC1sb2FkZXI6IHJlY29uY2lsaWF0aW9uIGZhaWxlZCcsICdjb3VsZCBub3QgZGl2ZSBpbnRvIFsnLCBjaGlsZCwgJ10gd2hpbGUgc29tZSBlbGVtZW50cyBhcmUgc3RpbGwgcHJlc2VudCBpbiB0aGUgdHJlZS4nKTtcbiAgICAgICAgICBzdGFja1JlcG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGFyaW5nIHJlbmRlcmVkIHR5cGUgdG8gZmliZXIuRWxlbWVudFR5cGVcbiAgICAgIGlmICgodHlwZW9mIGNoaWxkVHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2hpbGRUeXBlKSkgIT09IF90eXBlb2Yoc3RhY2tDaGlsZC5lbGVtZW50VHlwZSkpIHtcbiAgICAgICAgLy8gUG9ydGFscyBjb3VsZCBnZW5lcmF0ZSB1bmRlZmluZWQgIT09IG51bGxcbiAgICAgICAgaWYgKGNoaWxkVHlwZSAmJiBzdGFja0NoaWxkLnR5cGUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignUmVhY3QtaG90LWxvYWRlcjogZ290ICcsIGNoaWxkVHlwZSwgJ2luc3RlYWQgb2YnLCBzdGFja0NoaWxkLnR5cGUpO1xuICAgICAgICAgIHN0YWNrUmVwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNNZW1vVHlwZShjaGlsZCkgfHwgaXNMYXp5VHlwZShjaGlsZCkpIHtcbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIG1lbW8gY2hpbGRyZW5cbiAgICAgICAgaWYgKHN0YWNrQ2hpbGQuY2hpbGRyZW4gJiYgc3RhY2tDaGlsZC5jaGlsZHJlblswXSkge1xuICAgICAgICAgIHNjaGVkdWxlSW5zdGFuY2VVcGRhdGUoc3RhY2tDaGlsZC5jaGlsZHJlblswXS5pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRUeXBlID0gY2hpbGRUeXBlLnR5cGUgfHwgY2hpbGRUeXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3J3YXJkVHlwZShjaGlsZCkpIHtcbiAgICAgICAgbmV4dChzdGFja0NoaWxkLmluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0Q29uc3VtZXIoY2hpbGQpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNvbnRleHRWYWx1ZSA9IHN0YWNrQ29udGV4dCgpLmdldChnZXRDb250ZXh0UHJvdmlkZXIoY2hpbGRUeXBlKSk7XG4gICAgICAgICAgbmV4dCh7XG4gICAgICAgICAgICBjaGlsZHJlbjogKGNoaWxkLnByb3BzID8gY2hpbGQucHJvcHMuY2hpbGRyZW4gOiBjaGlsZC5jaGlsZHJlblswXSkoY29udGV4dFZhbHVlICE9PSB1bmRlZmluZWQgPyBjb250ZXh0VmFsdWUgOiBjaGlsZFR5cGVbQ09OVEVYVF9DVVJSRU5UX1ZBTFVFXSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGRvIG5vdGhpbmcsIHlldFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUmVhY3RcbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkVHlwZSA/IGdldENvbXBvbmVudERpc3BsYXlOYW1lKGNoaWxkVHlwZSkgOiAnZW1wdHknO1xuICAgICAgICB2YXIgZXh0cmFDb250ZXh0ID0gc3RhY2tDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKGNoaWxkKSkge1xuICAgICAgICAgIGV4dHJhQ29udGV4dCA9IG5ldyBNYXAoZXh0cmFDb250ZXh0KTtcbiAgICAgICAgICBleHRyYUNvbnRleHQuc2V0KGdldENvbnRleHRQcm92aWRlcihjaGlsZFR5cGUpLCBfZXh0ZW5kcyh7fSwgY2hpbGQubmV4dFByb3BzIHx8IHt9LCBjaGlsZC5wcm9wcyB8fCB7fSkudmFsdWUpO1xuICAgICAgICAgIGNoaWxkTmFtZSA9ICdDb250ZXh0UHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU3RhY2sucHVzaCh7XG4gICAgICAgICAgbmFtZTogY2hpbGROYW1lLFxuICAgICAgICAgIHR5cGU6IGNoaWxkVHlwZSxcbiAgICAgICAgICBwcm9wczogc3RhY2suaW5zdGFuY2UucHJvcHMsXG4gICAgICAgICAgY29udGV4dDogZXh0cmFDb250ZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5leHQoXG4gICAgICAgIC8vIG1vdmUgdHlwZXMgZnJvbSByZW5kZXIgdG8gdGhlIGluc3RhbmNlcyBvZiBoeWRyYXRlZCB0cmVlXG4gICAgICAgIG1lcmdlSW5qZWN0KHRyYW5zZm9ybUZsb3dOb2RlKGFzQXJyYXkoY2hpbGQucHJvcHMgPyBjaGlsZC5wcm9wcy5jaGlsZHJlbiA6IGNoaWxkLmNoaWxkcmVuKSksIHN0YWNrQ2hpbGQuaW5zdGFuY2UuY2hpbGRyZW4sIHN0YWNrQ2hpbGQuaW5zdGFuY2UpKTtcbiAgICAgICAgcmVuZGVyU3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2hpbGRUeXBlID09PSBzdGFja0NoaWxkLnR5cGUpIHtcbiAgICAgICAgICBuZXh0KHN0YWNrQ2hpbGQuaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVud3JhcCBwcm94eVxuICAgICAgICAgIHZhciBfY2hpbGRUeXBlID0gZ2V0RWxlbWVudFR5cGUoY2hpbGQpO1xuXG4gICAgICAgICAgaWYgKGlzTWVtb1R5cGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBfY2hpbGRUeXBlID0gX2NoaWxkVHlwZS50eXBlIHx8IF9jaGlsZFR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzdGFja0NoaWxkLnR5cGVbUFJPWFlfS0VZXSkge1xuICAgICAgICAgICAgaWYgKCFyZWFjdEhvdExvYWRlci5JU19SRUFDVF9NRVJHRV9FTkFCTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpc1R5cGVCbGFja2xpc3RlZChzdGFja0NoaWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1JlYWN0LWhvdC1sb2FkZXI6IGNvbGQgZWxlbWVudCBnb3QgdXBkYXRlZCAnLCBzdGFja0NoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUmVnaXN0ZXJlZENvbXBvbmVudChfY2hpbGRUeXBlKSB8fCBpc1JlZ2lzdGVyZWRDb21wb25lbnQoc3RhY2tDaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgLy8gb25lIG9mIGVsZW1lbnRzIGFyZSByZWdpc3RlcmVkIHZpYSBiYWJlbCBwbHVnaW4sIGFuZCBzaG91bGQgbm90IGJlIGhhbmRsZWQgYnkgaG90IHN3YXBcbiAgICAgICAgICAgIGlmIChyZXNvbHZlVHlwZShfY2hpbGRUeXBlKSA9PT0gcmVzb2x2ZVR5cGUoc3RhY2tDaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgICBuZXh0KHN0YWNrQ2hpbGQuaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJlU3dhcHBhYmxlKF9jaGlsZFR5cGUsIHN0YWNrQ2hpbGQudHlwZSkpIHtcbiAgICAgICAgICAgIC8vIHRoZXkgYXJlIGJvdGggcmVnaXN0ZXJlZCwgb3IgaGF2ZSBlcXVhbCBjb2RlL2Rpc3BsYXluYW1lL3NpZ25hdHVyZVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJveHkgdXNpbmcgaW50ZXJuYWwgUFJPWFlfS0VZXG4gICAgICAgICAgICB1cGRhdGVQcm94eUJ5SWQoc3RhY2tDaGlsZC50eXBlW1BST1hZX0tFWV0gfHwgZ2V0SWRCeVR5cGUoc3RhY2tDaGlsZC50eXBlKSwgX2NoaWxkVHlwZSk7XG5cbiAgICAgICAgICAgIG5leHQoc3RhY2tDaGlsZC5pbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdSZWFjdC1ob3QtbG9hZGVyOiBhICcgKyBnZXRDb21wb25lbnREaXNwbGF5TmFtZShfY2hpbGRUeXBlKSArICcgd2FzIGZvdW5kIHdoZXJlIGEgJyArIGdldENvbXBvbmVudERpc3BsYXlOYW1lKHN0YWNrQ2hpbGQpICsgJyB3YXMgZXhwZWN0ZWQuXFxuICAgICAgICAgICcgKyBfY2hpbGRUeXBlKTtcbiAgICAgICAgICAgIHN0YWNrUmVwb3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2NoZWR1bGVJbnN0YW5jZVVwZGF0ZShzdGFja0NoaWxkLmluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLnRoZW4pIDsgZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignUmVhY3QtaG90LWxvYWRlcjogcnVuIHRpbWUgZXJyb3IgZHVyaW5nIHJlY29uY2lsaWF0aW9uJywgZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzUmVhY3RDbGFzc0luc3RhbmNlKGluc3RhbmNlKSkge1xuICAgIHJlbmRlclN0YWNrLnBvcCgpO1xuICB9XG59O1xuXG52YXIgaG90UmVwbGFjZW1lbnRSZW5kZXIkMSA9IChmdW5jdGlvbiAoaW5zdGFuY2UsIHN0YWNrKSB7XG4gIGlmIChjb25maWd1cmF0aW9uLmRpc2FibGVIb3RSZW5kZXJlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIC8vIGRpc2FibGUgcmVjb25jaWxlciB0byBwcmV2ZW50IHVwY29taW5nIGNvbXBvbmVudHMgZnJvbSBwcm94eWluZy5cbiAgICBpbnRlcm5hbENvbmZpZ3VyYXRpb24uZGlzYWJsZVByb3h5Q3JlYXRpb24gPSB0cnVlO1xuICAgIHJlbmRlclN0YWNrID0gW107XG4gICAgaG90UmVwbGFjZW1lbnRSZW5kZXIoaW5zdGFuY2UsIHN0YWNrKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ2dlci53YXJuKCdSZWFjdC1ob3QtbG9hZGVyOiByZWNvbmNpbGF0aW9uIGZhaWxlZCBkdWUgdG8gZXJyb3InLCBlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpbnRlcm5hbENvbmZpZ3VyYXRpb24uZGlzYWJsZVByb3h5Q3JlYXRpb24gPSBmYWxzZTtcbiAgfVxufSk7XG5cbnZhciByZWNvbmNpbGVIb3RSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIHJlY29uY2lsZUhvdFJlcGxhY2VtZW50KFJlYWN0SW5zdGFuY2UpIHtcbiAgdmFyIHN0YWNrID0gZ2V0UmVhY3RTdGFjayhSZWFjdEluc3RhbmNlKTtcbiAgaG90UmVwbGFjZW1lbnRSZW5kZXIkMShSZWFjdEluc3RhbmNlLCBzdGFjayk7XG4gIGNsZWFudXBSZWFjdCgpO1xuICBkZWVwTWFya1VwZGF0ZShzdGFjayk7XG59O1xuXG52YXIgcmVuZGVyUmVjb25jaWxlciA9IGZ1bmN0aW9uIHJlbmRlclJlY29uY2lsZXIodGFyZ2V0LCBmb3JjZSkge1xuICAvLyB3ZSBhcmUgbm90IGluc2lkZSBwYXJlbnQgcmVjb25jaWxhdGlvblxuICB2YXIgY3VycmVudEdlbmVyYXRpb24gPSBnZXQkMSgpO1xuICB2YXIgY29tcG9uZW50R2VuZXJhdGlvbiA9IHRhcmdldFtSRU5ERVJFRF9HRU5FUkFUSU9OXTtcblxuICB0YXJnZXRbUkVOREVSRURfR0VORVJBVElPTl0gPSBjdXJyZW50R2VuZXJhdGlvbjtcblxuICBpZiAoIWludGVybmFsQ29uZmlndXJhdGlvbi5kaXNhYmxlUHJveHlDcmVhdGlvbikge1xuICAgIGlmICgoY29tcG9uZW50R2VuZXJhdGlvbiB8fCBmb3JjZSkgJiYgY29tcG9uZW50R2VuZXJhdGlvbiAhPT0gY3VycmVudEdlbmVyYXRpb24pIHtcbiAgICAgIGVudGVySG90VXBkYXRlKCk7XG4gICAgICByZWNvbmNpbGVIb3RSZXBsYWNlbWVudCh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGFzeW5jUmVjb25jaWxlZFJlbmRlcih0YXJnZXQpIHtcbiAgcmVuZGVyUmVjb25jaWxlcih0YXJnZXQsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcHJveHlXcmFwcGVyKGVsZW1lbnQpIHtcbiAgLy8gcG9zdCB3cmFwIG9uIHBvc3QgcmVuZGVyXG4gIGlmICghaW50ZXJuYWxDb25maWd1cmF0aW9uLmRpc2FibGVQcm94eUNyZWF0aW9uKSB7XG4gICAgdW5zY2hlZHVsZVVwZGF0ZSh0aGlzKTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWFwKHByb3h5V3JhcHBlcik7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcHJveHkgPSBnZXRQcm94eUJ5VHlwZShlbGVtZW50LnR5cGUpO1xuICAgIGlmIChwcm94eSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBlbGVtZW50LCB7XG4gICAgICAgIHR5cGU6IHByb3h5LmdldCgpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbnZhciBFUlJPUl9TVEFURSA9ICdyZWFjdF9ob3RfbG9hZGVyX2NhdGNoZWRfZXJyb3InO1xudmFyIEVSUk9SX1NUQVRFX1BST1RPID0gJ3JlYWN0X2hvdF9sb2FkZXJfY2F0Y2hlZF9lcnJvci1wcm90b3R5cGUnO1xudmFyIE9MRF9SRU5ERVIgPSAncmVhY3RfaG90X2xvYWRlcl9vcmlnaW5hbF9yZW5kZXInO1xuXG5mdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gIHRoaXNbRVJST1JfU1RBVEVdID0ge1xuICAgIGxvY2F0aW9uOiAnYm91bmRhcnknLFxuICAgIGVycm9yOiBlcnJvcixcbiAgICBlcnJvckluZm86IGVycm9ySW5mbyxcbiAgICBnZW5lcmF0aW9uOiBnZXQkMSgpXG4gIH07XG4gIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKVtFUlJPUl9TVEFURV9QUk9UT10gPSB0aGlzW0VSUk9SX1NUQVRFXTtcbiAgaWYgKCFjb25maWd1cmF0aW9uLmVycm9yUmVwb3J0ZXIpIHtcbiAgICBsb2dFeGNlcHRpb24oZXJyb3IsIGVycm9ySW5mbywgdGhpcyk7XG4gIH1cbiAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRSZW5kZXIoKSB7XG4gIHZhciBfcmVmID0gdGhpc1tFUlJPUl9TVEFURV0gfHwge30sXG4gICAgICBlcnJvciA9IF9yZWYuZXJyb3IsXG4gICAgICBlcnJvckluZm8gPSBfcmVmLmVycm9ySW5mbyxcbiAgICAgIGdlbmVyYXRpb24gPSBfcmVmLmdlbmVyYXRpb247XG5cbiAgaWYgKGVycm9yICYmIGdlbmVyYXRpb24gPT09IGdldCQxKCkpIHtcbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChjb25maWd1cmF0aW9uLmVycm9yUmVwb3J0ZXIgfHwgRW1wdHlFcnJvclBsYWNlaG9sZGVyLCB7XG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBlcnJvckluZm86IGVycm9ySW5mbyxcbiAgICAgIGNvbXBvbmVudDogdGhpc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuaG90Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgdGhpcy5ob3RDb21wb25lbnRVcGRhdGUoKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBfT0xEX1JFTkRFUiRyZW5kZXI7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gKF9PTERfUkVOREVSJHJlbmRlciA9IHRoaXNbT0xEX1JFTkRFUl0ucmVuZGVyKS5jYWxsLmFwcGx5KF9PTERfUkVOREVSJHJlbmRlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gIH0gY2F0Y2ggKHJlbmRlckVycm9yKSB7XG4gICAgdGhpc1tFUlJPUl9TVEFURV0gPSB7XG4gICAgICBsb2NhdGlvbjogJ3JlbmRlcicsXG4gICAgICBlcnJvcjogcmVuZGVyRXJyb3IsXG4gICAgICBnZW5lcmF0aW9uOiBnZXQkMSgpXG4gICAgfTtcbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uZXJyb3JSZXBvcnRlcikge1xuICAgICAgbG9nRXhjZXB0aW9uKHJlbmRlckVycm9yLCB1bmRlZmluZWQsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50UmVuZGVyLmNhbGwodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlIb3RMb2FkZXJFcnJvcigpIHtcbiAgZGVsZXRlIHRoaXNbRVJST1JfU1RBVEVdO1xuICB0aGlzLmZvcmNlVXBkYXRlKCk7XG59XG5cbnNldENvbXBhcmlzb25Ib29rcyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7fTtcbn0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgaWYgKCFob3RDb21wYXJpc29uT3BlbigpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwcm90b3R5cGUgPSBjb21wb25lbnQucHJvdG90eXBlO1xuXG4gIGlmICghcHJvdG90eXBlW09MRF9SRU5ERVJdKSB7XG4gICAgdmFyIHJlbmRlckRlc2NyaXB0aW9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsICdyZW5kZXInKTtcbiAgICBwcm90b3R5cGVbT0xEX1JFTkRFUl0gPSB7XG4gICAgICBkZXNjcmlwdG9yOiByZW5kZXJEZXNjcmlwdGlvciA/IHJlbmRlckRlc2NyaXB0aW9yLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyOiBwcm90b3R5cGUucmVuZGVyXG4gICAgfTtcbiAgICBwcm90b3R5cGUuY29tcG9uZW50RGlkQ2F0Y2ggPSBjb21wb25lbnREaWRDYXRjaDtcbiAgICBwcm90b3R5cGUucmV0cnlIb3RMb2FkZXJFcnJvciA9IHJldHJ5SG90TG9hZGVyRXJyb3I7XG5cbiAgICBwcm90b3R5cGUucmVuZGVyID0gY29tcG9uZW50UmVuZGVyO1xuICB9XG4gIGRlbGV0ZSBwcm90b3R5cGVbRVJST1JfU1RBVEVdO1xufSwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBwcm90b3R5cGUgPSBfcmVmMi5wcm90b3R5cGU7XG5cbiAgaWYgKHByb3RvdHlwZVtPTERfUkVOREVSXSkge1xuICAgIHZhciBfcmVmMyA9IHByb3RvdHlwZVtFUlJPUl9TVEFURV9QUk9UT10gfHwge30sXG4gICAgICAgIGdlbmVyYXRpb24gPSBfcmVmMy5nZW5lcmF0aW9uO1xuXG4gICAgaWYgKGdlbmVyYXRpb24gPT09IGdldCQxKCkpIDsgZWxzZSB7XG4gICAgICBkZWxldGUgcHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoO1xuICAgICAgZGVsZXRlIHByb3RvdHlwZS5yZXRyeUhvdExvYWRlckVycm9yO1xuICAgICAgaWYgKCFwcm90b3R5cGVbT0xEX1JFTkRFUl0uZGVzY3JpcHRvcikge1xuICAgICAgICBkZWxldGUgcHJvdG90eXBlLnJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvdHlwZS5yZW5kZXIgPSBwcm90b3R5cGVbT0xEX1JFTkRFUl0uZGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwcm90b3R5cGVbRVJST1JfU1RBVEVfUFJPVE9dO1xuICAgICAgZGVsZXRlIHByb3RvdHlwZVtPTERfUkVOREVSXTtcbiAgICB9XG4gIH1cbn0pO1xuXG5zZXRTdGFuZEluT3B0aW9ucyh7XG4gIGNvbXBvbmVudFdpbGxSZW5kZXI6IGFzeW5jUmVjb25jaWxlZFJlbmRlcixcbiAgY29tcG9uZW50RGlkUmVuZGVyOiBwcm94eVdyYXBwZXIsXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudFtSRU5ERVJFRF9HRU5FUkFUSU9OXSA9IGdldCQxKCk7XG4gICAgZmx1c2hTY2hlZHVsZWRVcGRhdGVzKCk7XG4gIH1cbn0pO1xuXG52YXIgQXBwQ29udGFpbmVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQXBwQ29udGFpbmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBBcHBDb250YWluZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZS5nZW5lcmF0aW9uICE9PSBnZXQkMSgpKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkIGlzIGhhcHBlbmluZy5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBnZW5lcmF0aW9uOiBnZXQkMSgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBBcHBDb250YWluZXIocHJvcHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBcHBDb250YWluZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIGlmIChjb25maWd1cmF0aW9uLnNob3dSZWFjdERvbVBhdGNoTm90aWZpY2F0aW9uKSB7XG4gICAgICBjb25maWd1cmF0aW9uLnNob3dSZWFjdERvbVBhdGNoTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlYWN0LUhvdC1Mb2FkZXI6IHJlYWN0LfCflKUtZG9tIHBhdGNoIGlzIG5vdCBkZXRlY3RlZC4gUmVhY3QgMTYuNisgZmVhdHVyZXMgbWF5IG5vdCB3b3JrLicpO1xuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBlcnJvckluZm86IG51bGwsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgICBnZW5lcmF0aW9uOiAwXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBcHBDb250YWluZXIucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIC8vIERvbid0IHVwZGF0ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBzdGF0ZSBoYWQgYW4gZXJyb3IgYW5kIHN0aWxsIGhhcyBvbmUuXG4gICAgLy8gVGhpcyBhbGxvd3MgdG8gYnJlYWsgYW4gaW5maW5pdGUgbG9vcCBvZiBlcnJvciAtPiByZW5kZXIgLT4gZXJyb3IgLT4gcmVuZGVyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZWFyb24vcmVhY3QtaG90LWxvYWRlci9pc3N1ZXMvNjk2XG4gICAgaWYgKHByZXZTdGF0ZS5lcnJvciAmJiB0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgQXBwQ29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRDYXRjaCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuXG4gICAgaWYgKCFob3RDb21wYXJpc29uT3BlbigpKSB7XG4gICAgICAvLyBkbyBub3QgbG9nIGVycm9yIG91dHNpZGUgb2YgSE1SIGN5Y2xlXG5cbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHRvIGtpY2sgZXJyb3JcbiAgICAgIHRoaXMuc2V0U3RhdGUoe30pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHZhciBfcHJvcHMkZXJyb3JSZXBvcnRlciA9IHRoaXMucHJvcHMuZXJyb3JSZXBvcnRlcixcbiAgICAgICAgZXJyb3JSZXBvcnRlciA9IF9wcm9wcyRlcnJvclJlcG9ydGVyID09PSB1bmRlZmluZWQgPyBjb25maWd1cmF0aW9uLmVycm9yUmVwb3J0ZXIgOiBfcHJvcHMkZXJyb3JSZXBvcnRlcjtcblxuICAgIGlmICghZXJyb3JSZXBvcnRlcikge1xuICAgICAgbG9nRXhjZXB0aW9uKGVycm9yLCBlcnJvckluZm8sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIGVycm9ySW5mbzogZXJyb3JJbmZvXG4gICAgfSk7XG4gIH07XG5cbiAgQXBwQ29udGFpbmVyLnByb3RvdHlwZS5yZXRyeUhvdExvYWRlckVycm9yID0gZnVuY3Rpb24gcmV0cnlIb3RMb2FkZXJFcnJvciQkMSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogbnVsbCB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXRyeUhvdExvYWRlckVycm9yLmNhbGwoX3RoaXMyKTtcbiAgICB9KTtcbiAgfTtcblxuICBBcHBDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgZXJyb3IgPSBfc3RhdGUuZXJyb3IsXG4gICAgICAgIGVycm9ySW5mbyA9IF9zdGF0ZS5lcnJvckluZm87XG4gICAgdmFyIF9wcm9wcyRlcnJvclJlcG9ydGVyMiA9IHRoaXMucHJvcHMuZXJyb3JSZXBvcnRlcixcbiAgICAgICAgRXJyb3JSZXBvcnRlciA9IF9wcm9wcyRlcnJvclJlcG9ydGVyMiA9PT0gdW5kZWZpbmVkID8gY29uZmlndXJhdGlvbi5lcnJvclJlcG9ydGVyIHx8IEVtcHR5RXJyb3JQbGFjZWhvbGRlciA6IF9wcm9wcyRlcnJvclJlcG9ydGVyMjtcblxuXG4gICAgaWYgKGVycm9yICYmIHRoaXMucHJvcHMuZXJyb3JCb3VuZGFyeSkge1xuICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRXJyb3JSZXBvcnRlciwgeyBlcnJvcjogZXJyb3IsIGVycm9ySW5mbzogZXJyb3JJbmZvLCBjb21wb25lbnQ6IHRoaXMgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG90Q29tcG9uZW50VXBkYXRlKSB7XG4gICAgICB0aGlzLmhvdENvbXBvbmVudFVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LUhvdC1Mb2FkZXI6IEFwcENvbnRhaW5lciBzaG91bGQgYmUgcGF0Y2hlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBBcHBDb250YWluZXI7XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCk7XG5cbkFwcENvbnRhaW5lci5yZWFjdEhvdExvYWRhYmxlID0gZmFsc2U7XG5cblxuQXBwQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKHByb3BzKSB7XG4gICAgaWYgKFJlYWN0X19kZWZhdWx0LkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSAhPT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBwcm9wIFwiY2hpbGRyZW5cIiBzdXBwbGllZCB0byBBcHBDb250YWluZXIuICcgKyAnRXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCB3aXRoIHlvdXIgYXBw4oCZcyByb290IGNvbXBvbmVudCwgZS5nLiA8QXBwIC8+LicpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZXJyb3JSZXBvcnRlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSksXG4gIGVycm9yQm91bmRhcnk6IFByb3BUeXBlcy5ib29sXG59O1xuXG5BcHBDb250YWluZXIuZGVmYXVsdFByb3BzID0ge1xuICBlcnJvckJvdW5kYXJ5OiB0cnVlXG59O1xuXG4vLyAgdHJ5aW5nIGZpcnN0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0LnBvbHlmaWxsLCB0aGVuIHRyeWluZyByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCwgd2hpY2ggY291bGQgYmUgLmRlZmF1bHRcbnZhciByZWFsUG9seWZpbGwgPSBkZWZhdWx0UG9seWZpbGwucG9seWZpbGwgfHwgZGVmYXVsdFBvbHlmaWxsX19kZWZhdWx0O1xucmVhbFBvbHlmaWxsKEFwcENvbnRhaW5lcik7XG5cbnZhciBsYXp5Q29uc3RydWN0b3IgPSAnX2N0b3InO1xuXG52YXIgdXBkYXRlTGF6eSA9IGZ1bmN0aW9uIHVwZGF0ZUxhenkodGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBjdG9yID0gdHlwZVtsYXp5Q29uc3RydWN0b3JdO1xuICBpZiAodGFyZ2V0W2xhenlDb25zdHJ1Y3Rvcl0gIT09IHR5cGVbbGF6eUNvbnN0cnVjdG9yXSkge1xuICAgIC8vIGp1c3QgZXhlY3V0ZSBgaW1wb3J0YCBhbmQgUkhMLnJlZ2lzdGVyIHdpbGwgZG8gdGhlIGpvYlxuICAgIGN0b3IoKTtcbiAgfVxuICBpZiAoIXRhcmdldFtsYXp5Q29uc3RydWN0b3JdLmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIpIHtcbiAgICB0YXJnZXRbbGF6eUNvbnN0cnVjdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdG9yKCkudGhlbihmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgQyA9IHJlc29sdmVUeXBlKG0uZGVmYXVsdCk7XG4gICAgICAgIC8vIGNodW5rcyBoYXMgYmVlbiB1cGRhdGVkIC0gbmV3IGhvdCBsb2FkZXIgcHJvY2VzcyBpcyB0YWtpbmcgYSBwbGFjZVxuICAgICAgICBlbnRlckhvdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoIVJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQocHJvcHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgQXBwQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDLCBwcm9wcylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVmYXVsdDogUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIEFwcENvbnRhaW5lcixcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgcmVmOiByZWYgfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhcmdldFtsYXp5Q29uc3RydWN0b3JdLmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIgPSB0cnVlO1xuICB9XG59O1xuXG52YXIgdXBkYXRlTWVtbyA9IGZ1bmN0aW9uIHVwZGF0ZU1lbW8odGFyZ2V0LCBfcmVmKSB7XG4gIHZhciB0eXBlID0gX3JlZi50eXBlO1xuXG4gIHRhcmdldC50eXBlID0gcmVzb2x2ZVR5cGUodHlwZSk7XG59O1xuXG52YXIgdXBkYXRlRm9yd2FyZCA9IGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmQodGFyZ2V0LCBfcmVmMikge1xuICB2YXIgcmVuZGVyID0gX3JlZjIucmVuZGVyO1xuXG4gIHRhcmdldC5yZW5kZXIgPSByZW5kZXI7XG59O1xuXG52YXIgdXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoKSB7XG4gIC8vIG5pbFxufTtcblxudmFyIGdldElubmVyQ29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uIGdldElubmVyQ29tcG9uZW50VHlwZShjb21wb25lbnQpIHtcbiAgdmFyIHVud3JhcHBlciA9IGNvbXBvbmVudFtVTldSQVBfUFJPWFldO1xuICByZXR1cm4gdW53cmFwcGVyID8gdW53cmFwcGVyKCkgOiBjb21wb25lbnQ7XG59O1xuXG5mdW5jdGlvbiBoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkge1xuICB2YXIgcHJldlNpZ25hdHVyZSA9IGdldFNpZ25hdHVyZShwcmV2VHlwZSk7XG4gIHZhciBuZXh0U2lnbmF0dXJlID0gZ2V0U2lnbmF0dXJlKG5leHRUeXBlKTtcblxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkICYmIG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgfHwgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcmV2U2lnbmF0dXJlLmtleSAhPT0gbmV4dFNpZ25hdHVyZS5rZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUT0RPOiB3ZSBtaWdodCBuZWVkIHRvIGNhbGN1bGF0ZSBwcmV2aW91cyBzaWduYXR1cmUgZWFybGllciBpbiBwcmFjdGljZSxcbiAgLy8gc3VjaCBhcyBkdXJpbmcgdGhlIGZpcnN0IHRpbWUgYSBjb21wb25lbnQgaXMgcmVzb2x2ZWQuIFdlJ2xsIHJldmlzaXQgdGhpcy5cbiAgdmFyIHByZXZDdXN0b21Ib29rcyA9IHByZXZTaWduYXR1cmUuZ2V0Q3VzdG9tSG9va3MoKTtcbiAgdmFyIG5leHRDdXN0b21Ib29rcyA9IG5leHRTaWduYXR1cmUuZ2V0Q3VzdG9tSG9va3MoKTtcbiAgaWYgKHByZXZDdXN0b21Ib29rcy5sZW5ndGggIT09IG5leHRDdXN0b21Ib29rcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDdXN0b21Ib29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGF2ZUVxdWFsU2lnbmF0dXJlcyhwcmV2Q3VzdG9tSG9va3NbaV0sIG5leHRDdXN0b21Ib29rc1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGFyZVNpZ25hdHVyZXNDb21wYXRpYmxlID0gZnVuY3Rpb24gYXJlU2lnbmF0dXJlc0NvbXBhdGlibGUoYSwgYikge1xuICAvLyBjb21wYXJlIHNpZ25hdHVyZXMgb2YgdHdvIGNvbXBvbmVudHNcbiAgLy8gbm9uLWVxdWFsIGNvbXBvbmVudCBoYXZlIHRvIHJlbW91bnQgYW5kIHRoZXJlIGlzIHR3byBvcHRpb25zIHRvIGRvIGl0XG4gIC8vIC0gZmFpbCB0aGUgY29tcGFyaXNvbiwgcmVtb3VudGluZyBhbGwgdHJlZSBiZWxvd1xuICAvLyAtIGZ1bGZpbGwgaXQsIGJ1dCBzZXQgYF9kZWJ1Z05lZWRzUmVtb3VudGAgb24gYSBmaWJlciB0byBkcm9wIG9ubHkgbG9jYWwgc3RhdGVcbiAgLy8gdGhlIHNlY29uZCB3YXkgaXMgbm90IHB1Ymxpc2hlZCB5ZXQsIHNvIGdvaW5nIHdpdGggdGhlIGZpcnN0IG9uZVxuICBpZiAoIWhhdmVFcXVhbFNpZ25hdHVyZXMoYSwgYikpIHtcbiAgICBsb2dnZXIud2Fybign4pqb77iP8J+UpfCfjqMgSG9vayBvcmRlciBjaGFuZ2UgZGV0ZWN0ZWQ6IGNvbXBvbmVudCcsIGEsICdoYXMgYmVlbiByZW1vdW50ZWQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY29tcGFyZVJlZ2lzdGVyZWQgPSBmdW5jdGlvbiBjb21wYXJlUmVnaXN0ZXJlZChhLCBiKSB7XG4gIGlmIChpc1JlZ2lzdGVyZWRDb21wb25lbnQoYSkgfHwgaXNSZWdpc3RlcmVkQ29tcG9uZW50KGIpKSB7XG4gICAgaWYgKHJlc29sdmVUeXBlKGEpICE9PSByZXNvbHZlVHlwZShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmVTaWduYXR1cmVzQ29tcGF0aWJsZShhLCBiKTtcbn07XG5cbnZhciBjb21wYXJlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGNvbXBhcmVDb21wb25lbnRzKG9sZFR5cGUsIG5ld1R5cGUsIHNldE5ld1R5cGUsIGJhc2VUeXBlKSB7XG4gIHZhciBkZWZhdWx0UmVzdWx0ID0gb2xkVHlwZSA9PT0gbmV3VHlwZTtcblxuICBpZiAob2xkVHlwZSAmJiAhbmV3VHlwZSB8fCAhb2xkVHlwZSAmJiBuZXdUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzUmVnaXN0ZXJlZENvbXBvbmVudChvbGRUeXBlKSB8fCBpc1JlZ2lzdGVyZWRDb21wb25lbnQobmV3VHlwZSkpIHtcbiAgICBpZiAoIWNvbXBhcmVSZWdpc3RlcmVkKG9sZFR5cGUsIG5ld1R5cGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlZmF1bHRSZXN1bHQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGlzRm9yd2FyZFR5cGUoeyB0eXBlOiBvbGRUeXBlIH0pICYmIGlzRm9yd2FyZFR5cGUoeyB0eXBlOiBuZXdUeXBlIH0pKSB7XG4gICAgaWYgKCFjb21wYXJlUmVnaXN0ZXJlZChvbGRUeXBlLnJlbmRlciwgbmV3VHlwZS5yZW5kZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvbGRUeXBlLnJlbmRlciA9PT0gbmV3VHlwZS5yZW5kZXIgfHwgYXJlU3dhcHBhYmxlKG9sZFR5cGUucmVuZGVyLCBuZXdUeXBlLnJlbmRlcikpIHtcbiAgICAgIHNldE5ld1R5cGUobmV3VHlwZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNZW1vVHlwZSh7IHR5cGU6IG9sZFR5cGUgfSkgJiYgaXNNZW1vVHlwZSh7IHR5cGU6IG5ld1R5cGUgfSkpIHtcbiAgICBpZiAoIWNvbXBhcmVSZWdpc3RlcmVkKG9sZFR5cGUudHlwZSwgbmV3VHlwZS50eXBlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2xkVHlwZS50eXBlID09PSBuZXdUeXBlLnR5cGUgfHwgYXJlU3dhcHBhYmxlKG9sZFR5cGUudHlwZSwgbmV3VHlwZS50eXBlKSkge1xuICAgICAgaWYgKGJhc2VUeXBlKSB7XG4gICAgICAgIC8vIG1lbW8gZm9ybSBkaWZmZXJlbnQgZmliZXJzLCB3aHk/XG4gICAgICAgIGlmIChiYXNlVHlwZS4kJHR5cGVvZiA9PT0gbmV3VHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIHNldE5ld1R5cGUobmV3VHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TmV3VHlwZShuZXdUeXBlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignUGxlYXNlIHVwZGF0ZSBob3QtbG9hZGVyL3JlYWN0LWRvbScpO1xuICAgICAgICBpZiAoaXNSZWFjdENsYXNzKG5ld1R5cGUudHlwZSkpIHtcbiAgICAgICAgICBzZXROZXdUeXBlKG5ld1R5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldE5ld1R5cGUobmV3VHlwZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG4gIH1cblxuICBpZiAoZGVmYXVsdFJlc3VsdCB8fCBuZXdUeXBlICE9PSBvbGRUeXBlICYmIGFyZVNpZ25hdHVyZXNDb21wYXRpYmxlKG5ld1R5cGUsIG9sZFR5cGUpICYmIGFyZVN3YXBwYWJsZShuZXdUeXBlLCBvbGRUeXBlKSkge1xuICAgIHZhciB1bndyYXBGYWN0b3J5ID0gbmV3VHlwZVtVTldSQVBfUFJPWFldO1xuICAgIHZhciBvbGRQcm94eSA9IHVud3JhcEZhY3RvcnkgJiYgZ2V0UHJveHlCeVR5cGUodW53cmFwRmFjdG9yeSgpKTtcbiAgICBpZiAob2xkUHJveHkpIHtcbiAgICAgIG9sZFByb3h5LmRlcmVmZXJlbmNlKCk7XG4gICAgICB1cGRhdGVQcm94eUJ5SWQob2xkVHlwZVtQUk9YWV9LRVldIHx8IGdldElkQnlUeXBlKG9sZFR5cGUpLCBnZXRJbm5lckNvbXBvbmVudFR5cGUobmV3VHlwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXROZXdUeXBlKG5ld1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxudmFyIGtub3duUGFpcnMgPSBuZXcgV2Vha01hcCgpO1xudmFyIGVtcHR5TWFwJDEgPSBuZXcgV2Vha01hcCgpO1xuXG52YXIgaG90Q29tcG9uZW50Q29tcGFyZSA9IGZ1bmN0aW9uIGhvdENvbXBvbmVudENvbXBhcmUob2xkVHlwZSwgcHJlTmV3VHlwZSwgc2V0TmV3VHlwZSwgYmFzZVR5cGUpIHtcbiAgdmFyIGhvdEFjdGl2ZSA9IGhvdENvbXBhcmlzb25PcGVuKCk7XG4gIHZhciBuZXdUeXBlID0gY29uZmlndXJhdGlvbi5pbnRlcmdyYXRlZFJlc29sdmVyID8gcmVzb2x2ZVR5cGUocHJlTmV3VHlwZSkgOiBwcmVOZXdUeXBlO1xuICB2YXIgcmVzdWx0ID0gb2xkVHlwZSA9PT0gbmV3VHlwZTtcblxuICBpZiAocmVzdWx0IHx8ICFpc1JlbG9hZGFibGVDb21wb25lbnQob2xkVHlwZSkgfHwgIWlzUmVsb2FkYWJsZUNvbXBvbmVudChuZXdUeXBlKSB8fCBpc0NvbGRUeXBlKG9sZFR5cGUpIHx8IGlzQ29sZFR5cGUob2xkVHlwZSkgfHwgIW9sZFR5cGUgfHwgIW5ld1R5cGUgfHwgMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBjb21wYXJpc29uIHNob3VsZCBiZSBhY3RpdmUgb25seSBpZiBob3QgdXBkYXRlIHdpbmRvd1xuICAvLyBvciBpdCB3b3VsZCBtZXJnZSBjb21wb25lbnRzIGl0IHNoYWxsIG5vdFxuICBpZiAoaG90QWN0aXZlKSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZUNvbXBvbmVudHMob2xkVHlwZSwgbmV3VHlwZSwgc2V0TmV3VHlwZSwgYmFzZVR5cGUpO1xuICAgIHZhciBfcGFpciA9IGtub3duUGFpcnMuZ2V0KG9sZFR5cGUpIHx8IG5ldyBXZWFrTWFwKCk7XG4gICAgX3BhaXIuc2V0KG5ld1R5cGUsIHJlc3VsdCk7XG4gICAga25vd25QYWlycy5zZXQob2xkVHlwZSwgX3BhaXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBwYWlyID0ga25vd25QYWlycy5nZXQob2xkVHlwZSkgfHwgZW1wdHlNYXAkMTtcbiAgcmV0dXJuIHBhaXIuZ2V0KG5ld1R5cGUpIHx8IGZhbHNlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxudmFyIGZvcmNlU2ltcGxlU0ZDID0geyBwcm94eTogeyBwdXJlU0ZDOiB0cnVlIH0gfTtcblxudmFyIGhvb2tXcmFwcGVyID0gZnVuY3Rpb24gaG9va1dyYXBwZXIoaG9vaykge1xuICB2YXIgd3JhcHBlZEhvb2sgPSBmdW5jdGlvbiB3cmFwcGVkSG9vayhjYiwgZGVwcykge1xuICAgIGlmIChjb25maWd1cmF0aW9uLnJlbG9hZEhvb2tzKSB7XG4gICAgICByZXR1cm4gaG9vayhjYiwgZGVwcyAmJiBkZXBzLmxlbmd0aCA+IDAgPyBbXS5jb25jYXQoZGVwcywgW2dldEhvdEdlbmVyYXRpb24oKV0pIDogZGVwcyk7XG4gICAgfVxuICAgIHJldHVybiBob29rKGNiLCBkZXBzKTtcbiAgfTtcbiAgd3JhcHBlZEhvb2suaXNQYXRjaGVkQnlSZWFjdEhvdExvYWRlciA9IHRydWU7XG4gIHJldHVybiB3cmFwcGVkSG9vaztcbn07XG5cbnZhciBub0RlcHMgPSBmdW5jdGlvbiBub0RlcHMoKSB7XG4gIHJldHVybiBbXTtcbn07XG5cbnZhciByZWFjdEhvdExvYWRlciA9IHtcbiAgSVNfUkVBQ1RfTUVSR0VfRU5BQkxFRDogZmFsc2UsXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKHR5cGUsIGtleSkge1xuICAgIHZhciBnZXRDdXN0b21Ib29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbm9EZXBzO1xuXG4gICAgYWRkU2lnbmF0dXJlKHR5cGUsIHsga2V5OiBrZXksIGdldEN1c3RvbUhvb2tzOiBnZXRDdXN0b21Ib29rcyB9KTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfSxcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIHVuaXF1ZUxvY2FsTmFtZSwgZmlsZU5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICB2YXIgaWQgPSBmaWxlTmFtZSArICcjJyArIHVuaXF1ZUxvY2FsTmFtZTtcblxuICAgIGlmIChpc0NvbXBvc2l0ZUNvbXBvbmVudCh0eXBlKSAmJiB0eXBlb2YgdW5pcXVlTG9jYWxOYW1lID09PSAnc3RyaW5nJyAmJiB1bmlxdWVMb2NhbE5hbWUgJiYgdHlwZW9mIGZpbGVOYW1lID09PSAnc3RyaW5nJyAmJiBmaWxlTmFtZSkge1xuICAgICAgdmFyIHByb3h5ID0gZ2V0UHJveHlCeUlkKGlkKTtcblxuICAgICAgaWYgKHByb3h5ICYmIHByb3h5LmdldEN1cnJlbnQoKSAhPT0gdHlwZSkge1xuICAgICAgICBpZiAoIXJlYWN0SG90TG9hZGVyLklTX1JFQUNUX01FUkdFX0VOQUJMRUQpIHtcbiAgICAgICAgICBpZiAoaXNUeXBlQmxhY2tsaXN0ZWQodHlwZSkgfHwgaXNUeXBlQmxhY2tsaXN0ZWQocHJveHkuZ2V0Q3VycmVudCgpKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWFjdC1ob3QtbG9hZGVyOiBDb2xkIGNvbXBvbmVudCcsIHVuaXF1ZUxvY2FsTmFtZSwgJ2F0JywgZmlsZU5hbWUsICdoYXMgYmVlbiB1cGRhdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWd1cmF0aW9uLm9uQ29tcG9uZW50UmVnaXN0ZXIpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5vbkNvbXBvbmVudFJlZ2lzdGVyKHR5cGUsIHVuaXF1ZUxvY2FsTmFtZSwgZmlsZU5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24ub25Db21wb25lbnRDcmVhdGUpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5vbkNvbXBvbmVudENyZWF0ZSh0eXBlLCBnZXRDb21wb25lbnREaXNwbGF5TmFtZSh0eXBlKSk7XG4gICAgICB9XG5cbiAgICAgIHJlZ2lzdGVyQ29tcG9uZW50KHVwZGF0ZVByb3h5QnlJZChpZCwgdHlwZSwgb3B0aW9ucykuZ2V0KCksIDIpO1xuICAgICAgcmVnaXN0ZXJDb21wb25lbnQodHlwZSk7XG4gICAgICBpbmNyZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKGlzQ29udGV4dFR5cGUoeyB0eXBlOiB0eXBlIH0pKSB7XG4gICAgICAvLyBwb3NzaWJsZSBvcHRpb25zIC0gQ29udGV4dCwgQ29uc3VtZXIsIFByb3ZpZGVyLlxuICAgICAgWydQcm92aWRlcicsICdDb25zdW1lciddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHR5cGUsIHByb3ApO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgdXBkYXRlRnVuY3Rpb25Qcm94eUJ5SWQoaWQgKyAnOicgKyBwcm9wLCBkZXNjcmlwdG9yLnZhbHVlLCB1cGRhdGVDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVGdW5jdGlvblByb3h5QnlJZChpZCwgdHlwZSwgdXBkYXRlQ29udGV4dCk7XG4gICAgICBpbmNyZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKGlzTGF6eVR5cGUoeyB0eXBlOiB0eXBlIH0pKSB7XG4gICAgICB1cGRhdGVGdW5jdGlvblByb3h5QnlJZChpZCwgdHlwZSwgdXBkYXRlTGF6eSk7XG4gICAgICBpbmNyZW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKGlzRm9yd2FyZFR5cGUoeyB0eXBlOiB0eXBlIH0pKSB7XG4gICAgICByZWFjdEhvdExvYWRlci5yZWdpc3Rlcih0eXBlLnJlbmRlciwgdW5pcXVlTG9jYWxOYW1lICsgJzpyZW5kZXInLCBmaWxlTmFtZSwgZm9yY2VTaW1wbGVTRkMpO1xuICAgICAgdXBkYXRlRnVuY3Rpb25Qcm94eUJ5SWQoaWQsIHR5cGUsIHVwZGF0ZUZvcndhcmQpO1xuICAgICAgaW5jcmVtZW50KCk7XG4gICAgfVxuICAgIGlmIChpc01lbW9UeXBlKHsgdHlwZTogdHlwZSB9KSkge1xuICAgICAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIodHlwZS50eXBlLCB1bmlxdWVMb2NhbE5hbWUgKyAnOm1lbW8nLCBmaWxlTmFtZSwgZm9yY2VTaW1wbGVTRkMpO1xuICAgICAgdXBkYXRlRnVuY3Rpb25Qcm94eUJ5SWQoaWQsIHR5cGUsIHVwZGF0ZU1lbW8pO1xuICAgICAgaW5jcmVtZW50KCk7XG4gICAgfVxuICB9LFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgcmVzZXRQcm94aWVzKCk7XG4gIH0sXG4gIHByZWFjdDogZnVuY3Rpb24gcHJlYWN0KGluc3RhbmNlKSB7XG4gICAgcHJlYWN0QWRhcHRlcihpbnN0YW5jZSwgcmVzb2x2ZVR5cGUpO1xuICB9LFxuICByZXNvbHZlVHlwZTogZnVuY3Rpb24gcmVzb2x2ZVR5cGUkJDEodHlwZSkge1xuICAgIHJldHVybiByZXNvbHZlVHlwZSh0eXBlKTtcbiAgfSxcbiAgcGF0Y2g6IGZ1bmN0aW9uIHBhdGNoKFJlYWN0JCQxLCBSZWFjdERPTSQkMSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBpZiAoUmVhY3RET00kJDEgJiYgUmVhY3RET00kJDEuc2V0SG90RWxlbWVudENvbXBhcmF0b3IpIHtcbiAgICAgIFJlYWN0RE9NJCQxLnNldEhvdEVsZW1lbnRDb21wYXJhdG9yKGhvdENvbXBvbmVudENvbXBhcmUpO1xuICAgICAgY29uZmlndXJhdGlvbi5kaXNhYmxlSG90UmVuZGVyZXIgPSBjb25maWd1cmF0aW9uLmRpc2FibGVIb3RSZW5kZXJlcldoZW5JbmplY3RlZDtcblxuICAgICAgY29uZmlndXJhdGlvbi5pZ25vcmVTRkMgPSBjb25maWd1cmF0aW9uLmlnbm9yZVNGQ1doZW5JbmplY3RlZDtcblxuICAgICAgcmVhY3RIb3RMb2FkZXIuSVNfUkVBQ1RfTUVSR0VfRU5BQkxFRCA9IHRydWU7XG4gICAgICBjb25maWd1cmF0aW9uLnNob3dSZWFjdERvbVBhdGNoTm90aWZpY2F0aW9uID0gZmFsc2U7XG5cbiAgICAgIGlmIChSZWFjdERPTSQkMS5zZXRIb3RUeXBlUmVzb2x2ZXIpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pbnRlcmdyYXRlZFJlc29sdmVyID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RET00kJDEuc2V0SG90VHlwZVJlc29sdmVyKHJlc29sdmVUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uaW50ZXJncmF0ZWRSZXNvbHZlcikge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgaWYgKCFSZWFjdCQkMS5jcmVhdGVFbGVtZW50LmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ3JlYXRlRWxlbWVudCA9IFJlYWN0JCQxLmNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIC8vIFRyaWNrIFJlYWN0IGludG8gcmVuZGVyaW5nIGEgcHJveHkgc28gdGhhdFxuICAgICAgICAvLyBpdHMgc3RhdGUgaXMgcHJlc2VydmVkIHdoZW4gdGhlIGNsYXNzIGNoYW5nZXMuXG4gICAgICAgIC8vIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHByb3h5IGlmIGl0J3MgZm9yIGEga25vd24gdHlwZS5cbiAgICAgICAgUmVhY3QkJDEuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDcmVhdGVFbGVtZW50LmFwcGx5KHVuZGVmaW5lZCwgW3Jlc29sdmVUeXBlKHR5cGUpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdCQkMS5jcmVhdGVFbGVtZW50LmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVJlYWN0JCQxLmNsb25lRWxlbWVudC5pc1BhdGNoZWRCeVJlYWN0SG90TG9hZGVyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENsb25lRWxlbWVudCA9IFJlYWN0JCQxLmNsb25lRWxlbWVudDtcblxuICAgICAgICBSZWFjdCQkMS5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld1R5cGUgPSBlbGVtZW50LnR5cGUgJiYgcmVzb2x2ZVR5cGUoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBpZiAobmV3VHlwZSAmJiBuZXdUeXBlICE9PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbENsb25lRWxlbWVudC5hcHBseSh1bmRlZmluZWQsIFtfZXh0ZW5kcyh7fSwgZWxlbWVudCwge1xuICAgICAgICAgICAgICB0eXBlOiBuZXdUeXBlXG4gICAgICAgICAgICB9KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ2xvbmVFbGVtZW50LmFwcGx5KHVuZGVmaW5lZCwgW2VsZW1lbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgUmVhY3QkJDEuY2xvbmVFbGVtZW50LmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVJlYWN0JCQxLmNyZWF0ZUZhY3RvcnkuaXNQYXRjaGVkQnlSZWFjdEhvdExvYWRlcikge1xuICAgICAgICAvLyBQYXRjaCBSZWFjdC5jcmVhdGVGYWN0b3J5IHRvIHVzZSBwYXRjaGVkIGNyZWF0ZUVsZW1lbnRcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgaW50ZXJuYWwsXG4gICAgICAgIC8vIHVucGF0Y2hlZCBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudFxuICAgICAgICBSZWFjdCQkMS5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB2YXIgZmFjdG9yeSA9IFJlYWN0JCQxLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAgICAgICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdCQkMS5jcmVhdGVGYWN0b3J5LmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVJlYWN0JCQxLkNoaWxkcmVuLm9ubHkuaXNQYXRjaGVkQnlSZWFjdEhvdExvYWRlcikge1xuICAgICAgICB2YXIgb3JpZ2luYWxDaGlsZHJlbk9ubHkgPSBSZWFjdCQkMS5DaGlsZHJlbi5vbmx5O1xuICAgICAgICAvLyBVc2UgdGhlIHNhbWUgdHJpY2sgYXMgUmVhY3QuY3JlYXRlRWxlbWVudFxuICAgICAgICBSZWFjdCQkMS5DaGlsZHJlbi5vbmx5ID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ2hpbGRyZW5Pbmx5KF9leHRlbmRzKHt9LCBjaGlsZHJlbiwgeyB0eXBlOiByZXNvbHZlVHlwZShjaGlsZHJlbi50eXBlKSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0JCQxLkNoaWxkcmVuLm9ubHkuaXNQYXRjaGVkQnlSZWFjdEhvdExvYWRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJlYWN0JCQxLnVzZUVmZmVjdCAmJiAhUmVhY3QkJDEudXNlRWZmZWN0LmlzUGF0Y2hlZEJ5UmVhY3RIb3RMb2FkZXIpIHtcbiAgICAgIFJlYWN0JCQxLnVzZUVmZmVjdCA9IGhvb2tXcmFwcGVyKFJlYWN0JCQxLnVzZUVmZmVjdCk7XG4gICAgICBSZWFjdCQkMS51c2VMYXlvdXRFZmZlY3QgPSBob29rV3JhcHBlcihSZWFjdCQkMS51c2VMYXlvdXRFZmZlY3QpO1xuICAgICAgUmVhY3QkJDEudXNlQ2FsbGJhY2sgPSBob29rV3JhcHBlcihSZWFjdCQkMS51c2VDYWxsYmFjayk7XG4gICAgICBSZWFjdCQkMS51c2VNZW1vID0gaG9va1dyYXBwZXIoUmVhY3QkJDEudXNlTWVtbyk7XG4gICAgfVxuXG4gICAgLy8gcmVhY3RIb3RMb2FkZXIucmVzZXQoKVxuICB9XG59O1xuXG52YXIgb3BlbmVkTW9kdWxlcyA9IHt9O1xudmFyIGxhc3RNb2R1bGVPcGVuZWQgPSAnJztcbnZhciBnZXRMYXN0TW9kdWxlT3BlbmVkID0gZnVuY3Rpb24gZ2V0TGFzdE1vZHVsZU9wZW5lZCgpIHtcbiAgcmV0dXJuIGxhc3RNb2R1bGVPcGVuZWQ7XG59O1xuXG52YXIgaG90TW9kdWxlcyA9IHt9O1xuXG52YXIgY3JlYXRlSG90TW9kdWxlID0gZnVuY3Rpb24gY3JlYXRlSG90TW9kdWxlKCkge1xuICByZXR1cm4geyBpbnN0YW5jZXM6IFtdLCB1cGRhdGVUaW1lb3V0OiAwIH07XG59O1xuXG52YXIgaG90TW9kdWxlID0gZnVuY3Rpb24gaG90TW9kdWxlKG1vZHVsZUlkKSB7XG4gIGlmICghaG90TW9kdWxlc1ttb2R1bGVJZF0pIHtcbiAgICBob3RNb2R1bGVzW21vZHVsZUlkXSA9IGNyZWF0ZUhvdE1vZHVsZSgpO1xuICB9XG4gIHJldHVybiBob3RNb2R1bGVzW21vZHVsZUlkXTtcbn07XG5cbnZhciBpc09wZW5lZCA9IGZ1bmN0aW9uIGlzT3BlbmVkKHNvdXJjZU1vZHVsZSkge1xuICByZXR1cm4gc291cmNlTW9kdWxlICYmICEhb3BlbmVkTW9kdWxlc1tzb3VyY2VNb2R1bGUuaWRdO1xufTtcblxudmFyIGVudGVyID0gZnVuY3Rpb24gZW50ZXIoc291cmNlTW9kdWxlKSB7XG4gIGlmIChzb3VyY2VNb2R1bGUgJiYgc291cmNlTW9kdWxlLmlkKSB7XG4gICAgbGFzdE1vZHVsZU9wZW5lZCA9IHNvdXJjZU1vZHVsZS5pZDtcbiAgICBvcGVuZWRNb2R1bGVzW3NvdXJjZU1vZHVsZS5pZF0gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlci53YXJuKCdSZWFjdC1ob3QtbG9hZGVyOiBubyBgbW9kdWxlYCB2YXJpYWJsZSBmb3VuZC4gRGlkIHlvdSBzaGFkb3cgYSBzeXN0ZW0gdmFyaWFibGU/Jyk7XG4gIH1cbn07XG5cbnZhciBsZWF2ZSA9IGZ1bmN0aW9uIGxlYXZlKHNvdXJjZU1vZHVsZSkge1xuICBpZiAoc291cmNlTW9kdWxlICYmIHNvdXJjZU1vZHVsZS5pZCkge1xuICAgIGRlbGV0ZSBvcGVuZWRNb2R1bGVzW3NvdXJjZU1vZHVsZS5pZF07XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW5kZWYgKi9cbnZhciByZXF1aXJlSW5kaXJlY3QgPSB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fIDogcmVxdWlyZTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGNoYXJnZUZhaWxiYWNrVGltZXIgPSBmdW5jdGlvbiBjaGFyZ2VGYWlsYmFja1RpbWVyKGlkKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyb3IgPSAnaG90IHVwZGF0ZSBmYWlsZWQgZm9yIG1vZHVsZSBcIicgKyBpZCArICdcIi4gTGFzdCBmaWxlIHByb2Nlc3NlZDogXCInICsgZ2V0TGFzdE1vZHVsZU9wZW5lZCgpICsgJ1wiLic7XG4gICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICBsb2dFeGNlcHRpb24oe1xuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gMTAwIG1zIG1vcmUgXCJjb2RlXCIgdG9sZXJhbnQgdGhhdCAwLCBhbmQgd291bGQgY2F0Y2ggZXJyb3IgaW4gYW55IGNhc2VcbiAgfSwgMTAwKTtcbn07XG5cbnZhciBjbGVhckZhaWxiYWNrVGltZXIgPSBmdW5jdGlvbiBjbGVhckZhaWxiYWNrVGltZXIodGltZXJJZCkge1xuICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xufTtcblxudmFyIGNyZWF0ZUhvYyA9IGZ1bmN0aW9uIGNyZWF0ZUhvYyhTb3VyY2VDb21wb25lbnQsIFRhcmdldENvbXBvbmVudCkge1xuICBob2lzdE5vblJlYWN0U3RhdGljKFRhcmdldENvbXBvbmVudCwgU291cmNlQ29tcG9uZW50KTtcbiAgVGFyZ2V0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0hvdEV4cG9ydGVkJyArIGdldENvbXBvbmVudERpc3BsYXlOYW1lKFNvdXJjZUNvbXBvbmVudCk7XG4gIHJldHVybiBUYXJnZXRDb21wb25lbnQ7XG59O1xuXG52YXIgbWFrZUhvdEV4cG9ydCA9IGZ1bmN0aW9uIG1ha2VIb3RFeHBvcnQoc291cmNlTW9kdWxlLCBtb2R1bGVJZCkge1xuICB2YXIgdXBkYXRlSW5zdGFuY2VzID0gZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2VzKHBvc3NpYmxlRXJyb3IpIHtcbiAgICBpZiAocG9zc2libGVFcnJvciAmJiBwb3NzaWJsZUVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IocG9zc2libGVFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtb2R1bGUgPSBob3RNb2R1bGUobW9kdWxlSWQpO1xuICAgIGNsZWFyVGltZW91dChtb2R1bGUudXBkYXRlVGltZW91dCk7XG4gICAgbW9kdWxlLnVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVpcmVJbmRpcmVjdChtb2R1bGVJZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWN0LUhvdC1Mb2FkZXI6IGVycm9yIGRldGVjdGVkIHdoaWxlIGxvYWRpbmcnLCBtb2R1bGVJZCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBtb2R1bGUuaW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmIChzb3VyY2VNb2R1bGUuaG90KSB7XG4gICAgLy8gTWFyayBhcyBzZWxmLWFjY2VwdGVkIGZvciBXZWJwYWNrIChjYWxsYmFjayBpcyBhbiBFcnJvciBIYW5kbGVyKVxuICAgIC8vIFVwZGF0ZSBpbnN0YW5jZXMgZm9yIFBhcmNlbCAoY2FsbGJhY2sgaXMgYW4gQWNjZXB0IEhhbmRsZXIpXG4gICAgc291cmNlTW9kdWxlLmhvdC5hY2NlcHQodXBkYXRlSW5zdGFuY2VzKTtcblxuICAgIC8vIFdlYnBhY2sgd2F5XG4gICAgaWYgKHNvdXJjZU1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcikge1xuICAgICAgaWYgKHNvdXJjZU1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJykge1xuICAgICAgICBzb3VyY2VNb2R1bGUuaG90LmFkZFN0YXR1c0hhbmRsZXIoZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdhcHBseScpIHtcbiAgICAgICAgICAgIGNsZWFyRXhjZXB0aW9ucygpO1xuICAgICAgICAgICAgdXBkYXRlSW5zdGFuY2VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyLndhcm4oJ1JlYWN0LWhvdC1sb2FkZXI6IEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgaXMgbm90IGVuYWJsZWQnKTtcbiAgfVxufTtcblxudmFyIGhvdCA9IGZ1bmN0aW9uIGhvdChzb3VyY2VNb2R1bGUpIHtcbiAgaWYgKCFzb3VyY2VNb2R1bGUpIHtcbiAgICAvLyB0aGlzIGlzIGZhdGFsXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC1ob3QtbG9hZGVyOiBgaG90YCB3YXMgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50IHByb3ZpZGVkJyk7XG4gIH1cbiAgdmFyIG1vZHVsZUlkID0gc291cmNlTW9kdWxlLmlkIHx8IHNvdXJjZU1vZHVsZS5pIHx8IHNvdXJjZU1vZHVsZS5maWxlbmFtZTtcbiAgaWYgKCFtb2R1bGVJZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2Btb2R1bGVgIHByb2RpdmVkJywgc291cmNlTW9kdWxlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LWhvdC1sb2FkZXI6IGBob3RgIGNvdWxkIG5vdCBmaW5kIHRoZSBgbmFtZWAgb2YgdGhlIHRoZSBgbW9kdWxlYCB5b3UgaGF2ZSBwcm92aWRlZCcpO1xuICB9XG4gIHZhciBtb2R1bGUgPSBob3RNb2R1bGUobW9kdWxlSWQpO1xuICBtYWtlSG90RXhwb3J0KHNvdXJjZU1vZHVsZSwgbW9kdWxlSWQpO1xuXG4gIGNsZWFyRXhjZXB0aW9ucygpO1xuICB2YXIgZmFpbGJhY2tUaW1lciA9IGNoYXJnZUZhaWxiYWNrVGltZXIobW9kdWxlSWQpO1xuICB2YXIgZmlyc3RIb3RSZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYWxsIGV4cG9ydHMgZnJvbSB0aGlzIGZpbGUgYXJlIHJlYWN0IGNvbXBvbmVudHMuXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcykge1xuICAgIGNsZWFyRmFpbGJhY2tUaW1lcihmYWlsYmFja1RpbWVyKTtcbiAgICAvLyByZWdpc3RlciBwcm94eSBmb3Igd3JhcHBlZCBjb21wb25lbnRcbiAgICAvLyBvbmx5IG9uZSBob3QgcGVyIGZpbGUgd291bGQgdXNlIHRoaXMgcmVnaXN0cmF0aW9uXG4gICAgaWYgKCFmaXJzdEhvdFJlZ2lzdGVyZWQpIHtcbiAgICAgIGZpcnN0SG90UmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihXcmFwcGVkQ29tcG9uZW50LCBnZXRDb21wb25lbnREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSwgJ1JITCcgKyBtb2R1bGVJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUhvYyhXcmFwcGVkQ29tcG9uZW50LCBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgaW5oZXJpdHMoRXhwb3J0ZWRDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBFeHBvcnRlZENvbXBvbmVudCgpIHtcbiAgICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwb3J0ZWRDb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICBFeHBvcnRlZENvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgbW9kdWxlLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgRXhwb3J0ZWRDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmIChpc09wZW5lZChzb3VyY2VNb2R1bGUpKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlYWN0LWhvdC1sb2FkZXI6IERldGVjdGVkIEFwcENvbnRhaW5lciB1bm1vdW50IG9uIG1vZHVsZSBcXCcnICsgbW9kdWxlSWQgKyAnXFwnIHVwZGF0ZS5cXG4nICsgKCdEaWQgeW91IHVzZSBcImhvdCgnICsgY29tcG9uZW50TmFtZSArICcpXCIgYW5kIFwiUmVhY3RET00ucmVuZGVyKClcIiBpbiB0aGUgc2FtZSBmaWxlP1xcbicpICsgKCdcImhvdCgnICsgY29tcG9uZW50TmFtZSArICcpXCIgc2hhbGwgb25seSBiZSB1c2VkIGFzIGV4cG9ydC5cXG4nKSArICdQbGVhc2UgcmVmZXIgdG8gXCJHZXR0aW5nIFN0YXJ0ZWRcIiAoaHR0cHM6Ly9naXRodWIuY29tL2dhZWFyb24vcmVhY3QtaG90LWxvYWRlci8pLicpO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZS5pbnN0YW5jZXMgPSBtb2R1bGUuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBhICE9PSBfdGhpczI7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgRXhwb3J0ZWRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgQXBwQ29udGFpbmVyLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5wcm9wcylcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBFeHBvcnRlZENvbXBvbmVudDtcbiAgICB9KFJlYWN0LkNvbXBvbmVudCkpO1xuICB9O1xufTtcblxudmFyIGdldFByb3h5T3JUeXBlID0gZnVuY3Rpb24gZ2V0UHJveHlPclR5cGUodHlwZSkge1xuICB2YXIgcHJveHkgPSBnZXRQcm94eUJ5VHlwZSh0eXBlKTtcbiAgcmV0dXJuIHByb3h5ID8gcHJveHkuZ2V0KCkgOiB0eXBlO1xufTtcblxudmFyIGFyZUNvbXBvbmVudHNFcXVhbCA9IGZ1bmN0aW9uIGFyZUNvbXBvbmVudHNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBnZXRQcm94eU9yVHlwZShhKSA9PT0gZ2V0UHJveHlPclR5cGUoYik7XG59O1xuXG52YXIgY29tcGFyZU9yU3dhcCA9IGZ1bmN0aW9uIGNvbXBhcmVPclN3YXAob2xkVHlwZSwgbmV3VHlwZSkge1xuICByZXR1cm4gaG90Q29tcG9uZW50Q29tcGFyZShvbGRUeXBlLCBuZXdUeXBlKTtcbn07XG5cbnZhciBjb2xkID0gZnVuY3Rpb24gY29sZCh0eXBlKSB7XG4gIGJsYWNrbGlzdEJ5VHlwZSh0eXBlKTtcbiAgcmV0dXJuIHR5cGU7XG59O1xuXG52YXIgY29uZmlndXJlQ29tcG9uZW50ID0gZnVuY3Rpb24gY29uZmlndXJlQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuICByZXR1cm4gc2V0Q29tcG9uZW50T3B0aW9ucyhjb21wb25lbnQsIG9wdGlvbnMpO1xufTtcblxudmFyIHNldENvbmZpZyA9IGZ1bmN0aW9uIHNldENvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIHNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbn07XG5cbnJlYWN0SG90TG9hZGVyLnBhdGNoKFJlYWN0X19kZWZhdWx0LCBSZWFjdERPTSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlYWN0SG90TG9hZGVyO1xuZXhwb3J0cy5BcHBDb250YWluZXIgPSBBcHBDb250YWluZXI7XG5leHBvcnRzLmhvdCA9IGhvdDtcbmV4cG9ydHMuZW50ZXJNb2R1bGUgPSBlbnRlcjtcbmV4cG9ydHMubGVhdmVNb2R1bGUgPSBsZWF2ZTtcbmV4cG9ydHMuYXJlQ29tcG9uZW50c0VxdWFsID0gYXJlQ29tcG9uZW50c0VxdWFsO1xuZXhwb3J0cy5jb21wYXJlT3JTd2FwID0gY29tcGFyZU9yU3dhcDtcbmV4cG9ydHMuY29sZCA9IGNvbGQ7XG5leHBvcnRzLmNvbmZpZ3VyZUNvbXBvbmVudCA9IGNvbmZpZ3VyZUNvbXBvbmVudDtcbmV4cG9ydHMuc2V0Q29uZmlnID0gc2V0Q29uZmlnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-hot-loader/dist/react-hot-loader.development.js\n");

/***/ })

}]);